"""Module for georeferencing hyperspectral imagery and processing IMU data.
Provides classes and methods to parse IMU files, compute geospatial transforms,
and generate georeferenced outputs such as GeoTIFFs.
"""

# Imports
import json
import logging
import math
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import pyproj
import pyresample
import rasterio
from numpy.typing import ArrayLike, NDArray
from pyproj import CRS, Proj
from pyresample.geometry import AreaDefinition, SwathDefinition
from pyresample.kd_tree import resample_nearest
from rasterio.crs import CRS
from rasterio.io import MemoryFile
from rasterio.plot import reshape_as_raster
from rasterio.profiles import DefaultGTiffProfile
from rasterio.transform import Affine, from_bounds
from rasterio.warp import Resampling, calculate_default_transform, reproject
from scipy.interpolate import make_smoothing_spline

import massipipe.utils as mpu

# Get logger
logger = logging.getLogger(__name__)


class ImuDataParser:
    """
    ImuDataParser is a utility class for parsing and processing IMU (Inertial
    Measurement Unit) data files generated by Resonon Airborne Hyperspectral imagers. It
    provides methods to read location files (.lcf), image line timestamps (.times)
    files, and interpolate the IMU data to match the image timestamps.
    """

    @staticmethod
    def read_lcf_file(
        lcf_file_path: Union[str, Path],
        convert_to_unix_time: bool = True,
        time_rel_to_file_start: bool = False,
    ) -> Dict[str, NDArray]:
        """Read location files (.lcf) generated by Resonon Airborne Hyperspectral imager

        Parameters
        ----------
        lcf_file_path: Union[str, Path]
            Path to lcf file. Usually a "sidecar" file to an hyperspectral image with
            same "base" filename.
        convert_to_unix_time: bool, default True
            Whether to convert timestamps to UNIX time, which is standard for many
            computer / sensor systems. Timestamps in LCF file are originally in "GPS
            time" (see
            https://en.wikipedia.org/wiki/Global_Positioning_System#Timekeeping)
        time_rel_to_file_start: bool, default False
            Boolean indicating if first timestamp should be subtracted from each
            timestamp, making time relative to start of file. If True, the value of
            convert_to_unix_time as no effect.

        Returns
        -------
        lcf_data: Dict[str, NDArray]
            Dictionary with keys describing the type of data, and data formatted as
            numpy arrays. All arrays have equal length. The 7 types of data (keys) are:
                'time': System time in seconds (GPS time).
                'roll': Roll angle in radians, positive for "right wing up".
                'pitch': Pitch angle in radians,positive nose up.
                'yaw': (heading) in radians, zero at due North, PI/2 at due East.
                'longitude': Longitude in decimal degrees, negative for west longitude.
                'latitude': Latitude in decimal degrees, negative for southern
                hemisphere.
                'altitude': Altitude in meters relative to the WGS-84 ellipsiod.

        Notes
        -----
        The LCF file format was shared by Casey Smith at Resonon on February 16. 2021.
        The LCF specification was inherited from Space Computer Corp.
        """
        try:
            lcf_raw = np.loadtxt(lcf_file_path)
        except Exception as e:
            logger.error(f"Error reading LCF file {lcf_file_path}: {e}")
            raise
        column_headers = [
            "time",
            "roll",
            "pitch",
            "yaw",
            "longitude",
            "latitude",
            "altitude",
        ]
        lcf_data = {header: lcf_raw[:, i] for i, header in enumerate(column_headers)}

        if convert_to_unix_time:
            lcf_data["time"] += mpu.gps2unix(lcf_data["time"][0]) - lcf_data["time"][0]

        if time_rel_to_file_start:
            lcf_data["time"] -= lcf_data["time"][0]

        return lcf_data

    @staticmethod
    def read_times_file(
        times_file_path: Union[Path, str], time_rel_to_file_start: bool = True
    ) -> NDArray:
        """Read image line timestamps (.times) file generated by Resonon camera

        Parameters
        ----------
        times_file_path: Union[Path,str]
            Path to times file. Usually a "sidecar" file to an hyperspectral image with
            same "base" filename.
        time_rel_to_file_start: bool, default True
            Boolean indicating if times should be offset so that first timestamp is
            zero. If not, the original timestamp value is returned.

        Returns
        -------
        times: NDArray
            Numpy array containing timestamps for every line of the corresponding
            hyperspectral image. The timestamps are in units of seconds, and are
            relative to when the system started (values are usually within the 0-10000
            second range). If time_rel_to_file_start=True, the times are offset so that
            the first timestamp is zero. The first timestamp of the times file and the
            first timestamp of the corresponding lcf file (GPS/IMU data) are assumed to
            the recorded at exactly the same time. If both sets of timestamps are offset
            so that time is measured relative to the start of the file, the times can be
            used to calculate interpolated GPS/IMU values for each image line.
        """
        try:
            image_times = np.loadtxt(times_file_path)
        except Exception as e:
            logger.error(f"Error reading times file {times_file_path}: {e}")
            raise
        if time_rel_to_file_start:
            image_times = image_times - image_times[0]
        return image_times

    @staticmethod
    def interpolate_lcf_to_times(
        lcf_data: Dict[str, NDArray], image_times: NDArray, convert_to_list: bool = True
    ) -> Dict[str, Union[List, NDArray]]:
        """Interpolate LCF data to image line times

        Parameters
        ----------
        lcf_data : dict
            Dictionary with data read from *.lcf file
        image_times : NDArray
            Array of time stamps from *.times file
        convert_to_list : bool, default True
            Whether to convert interpolated LCF data to list (useful for saving data as
            JSON). If False, interpolated values in lcf_data_interp are formatted as
            NDArray.

        Returns
        -------
        lcf_data_interp: dict[list | NDArray]
            Version of lcf_data with all measured values interpolated to image
            timestamps.
        """
        lcf_data_interp = {}
        lcf_times = lcf_data["time"]

        # LCF times and image times are both measured in seconds, but with different
        # offsets. "Sync" image times so they correspond to LCF time offset:
        image_times = image_times - image_times[0] + lcf_times[0]

        for lcf_key, lcf_value in lcf_data.items():
            lcf_data_interp[lcf_key] = np.interp(image_times, lcf_times, lcf_value)
            if convert_to_list:
                lcf_data_interp[lcf_key] = lcf_data_interp[lcf_key].tolist()
        return lcf_data_interp

    def read_and_save_imu_data(
        self,
        lcf_path: Union[Path, str],
        times_path: Union[Path, str],
        json_path: Union[Path, str],
    ) -> None:
        """Parse *.lcf and *.times files and save as JSON

        Parameters
        ----------
        lcf_path : Union[Path, str]
            Path to *.lcf (IMU data) file
        times_path : Union[Path, str]
            Path to *.times (image line timestamps) file
        json_path : Union[Path, str]
            Path to output JSON file
        """
        try:
            lcf_data = self.read_lcf_file(lcf_path)
            times_data = self.read_times_file(times_path)
            lcf_data_interp = self.interpolate_lcf_to_times(lcf_data, times_data)

            with open(json_path, "w", encoding="utf-8") as write_file:
                json.dump(lcf_data_interp, write_file, ensure_ascii=False, indent=4)
        except Exception as e:
            logger.error(f"Error processing IMU data: {e}")
            raise


class ImuGeoTransformer:
    """
    Class for calculating affine geotransform based on IMU data and image shape.

    Attributes
    ----------
    camera_opening_angle : float
        Full opening angle of camera, in radians.
    pitch_offset : float
        Forward pointing angle of the camera relative to nadir, in radians.
    roll_offset : float
        Right pointing angle of the camera relative to nadir, in radians.
    altitude_offset : float
        Offset added to the estimated altitude.
    utm_x_offset : float
        Offset in the UTM x-coordinate.
    utm_y_offset : float
        Offset in the UTM y-coordinate.
    imu_data : dict
        IMU data loaded from JSON file.
    image_shape : tuple
        Shape of the hyperspectral image.
    utm_x : float
        UTM x-coordinate of the IMU data.
    utm_y : float
        UTM y-coordinate of the IMU data.
    camera_origin : NDArray
        Origin of the camera in UTM coordinates.
    t_total : float
        Total time duration of IMU data.
    dt : float
        Sampling interval of IMU data.
    v_alongtrack : NDArray
        Along-track velocity vector, in m/s.
    u_alongtrack: NDArray
        Unit vector (easting, northing) pointing along flight direction
    gsd_alongtrack : float
        Ground sampling distance along track.
    swath_length : float
        Length of the swath along track.
    mean_altitude : float
        Mean altitude of the UAV during imaging.
    u_acrosstrack: NDArray
        Unit vector (easting, northing) pointing left relative to flight direction. The
        direction is chosen to match that of the image coordinate system: Origin in
        upper left corner, down (increasing line number) corresponds to positive
        along-track direction, right (increasing sample number) corresponds to positive
        cross-track direction.
    swath_width : float
        Width of the swath across track.
    gsd_acrosstrack : float
        Ground sampling distance across track.
    image_origin : NDArray
        Coordinates of the image origin.
    geotransform : tuple
        6-element affine transform for the image.
    rotation_deg : float
        Image rotation in degrees.
    utm_zone_number : int
        UTM zone number.
    utm_zone_hemi : str
        UTM hemisphere (North or South).
    envi_map_info : str
        ENVI "map info" string, including image rotation.

    """

    def __init__(
        self,
        imu_data_path: Union[Path, str],
        image_header_path: Union[Path, str],
        camera_opening_angle: Optional[float] = None,
        pitch_offset: Optional[float] = None,
        roll_offset: Optional[float] = None,
        altitude_offset: Optional[float] = None,
        utm_x_offset: Optional[float] = None,
        utm_y_offset: Optional[float] = None,
        assume_square_pixels: Optional[bool] = True,
    ):
        """Initialize image flight metadata object

        Parameters
        ----------
        imu_data_path : Union[Path, str]
            Path to JSON file with IMU data
        image_header_path : Union[Path, str]
            Path to header for hyperspectral image
        camera_opening_angle : float, default 36.5
            Full opening angle of camera, in degrees. Corresponds to angle between rays
            hitting leftmost and rightmost pixels of image.
        pitch_offset : float, default 0.0
            How much forward the camera is pointing relative to nadir (degrees)
        roll_offset : float, default 0.0
            How much to the right ("right wing up") the camera is pointing relative to
            nadir (degrees).
        altitude_offset : float, default 0.0
            Offset added to the estimated altitude. If the UAV was higher in reality
            than that estimated by the GeoTransformer object, add a positive
            altitude_offset.
        utm_x_offset, utm_y_offset: float, default 0.0
            How far from the real position the IMU data position is, measured in meters.
            If the IMU data is too far east, utm_x_offset is positive. If the IMU data
            is too far north, utm_y_offset is positive. The offset is assumed to be
            constant across a dataset.
        assume_square_pixels : bool, default True
            Whether to assume that the original image was acquired with flight
            parameters (flight speed, frame rate, altitude) that would produce square
            pixels. If true, the altitude of the camera is estimated from the shape of
            the image and the (along-track) swath length. This can be useful in cases
            where absolute altitude measurement of the camera IMU is not very accurate.
        """

        # Set default values
        camera_opening_angle = camera_opening_angle if camera_opening_angle else 36.5
        pitch_offset = pitch_offset if pitch_offset else 0.0
        roll_offset = roll_offset if roll_offset else 0.0
        altitude_offset = altitude_offset if altitude_offset else 0.0
        utm_x_offset = utm_x_offset if utm_x_offset else 0.0
        utm_y_offset = utm_y_offset if utm_y_offset else 0.0
        assume_square_pixels = (
            True if assume_square_pixels or (assume_square_pixels is None) else False
        )

        # Set attributes, converting degrees to radians
        self.camera_opening_angle = camera_opening_angle * (np.pi / 180)
        self.pitch_offset = pitch_offset * (np.pi / 180)
        self.roll_offset = roll_offset * (np.pi / 180)
        self.altitude_offset = altitude_offset
        self.utm_x_offset = utm_x_offset
        self.utm_y_offset = utm_y_offset

        try:
            # Get imu data and image shape from files
            self.imu_data = mpu.read_json(imu_data_path)
            self.image_shape = mpu.get_image_shape(image_header_path)

            # Get UTM coordinates and CRS code
            self.utm_x, self.utm_y, self.utm_epsg = mpu.convert_long_lat_to_utm(
                self.imu_data["longitude"], self.imu_data["latitude"]
            )
            self.utm_x -= self.utm_x_offset
            self.utm_y -= self.utm_y_offset
            self.camera_origin = np.array([self.utm_x[0], self.utm_y[0]])

            # Time-related attributes
            t_total, dt = self._calc_time_attributes()
            self.t_total = t_total
            self.dt = dt

            # Along-track properties
            v_at, u_at, gsd_at, sl = self._calc_alongtrack_properties()
            self.v_alongtrack = v_at
            self.u_alongtrack = u_at
            self.gsd_alongtrack = gsd_at
            self.swath_length = sl

            # Altitude
            self.mean_altitude = self._calc_mean_altitude(assume_square_pixels)

            # Cross-track properties
            u_ct, sw, gsd_ct = self._calc_acrosstrack_properties()
            self.u_acrosstrack = u_ct
            self.swath_width = sw
            self.gsd_acrosstrack = gsd_ct

            # Image origin (image transform offset)
            self.image_origin = self._calc_image_origin()

            # Affine transform
            self.geotransform = self.get_image_transform(ordering="alphabetical")

            # Image rotation (degrees)
            self.rotation_deg = self._calc_image_rotation()

            # UTM zone
            utm_zone_number, utm_zone_hemi = self._get_utm_zone()
            self.utm_zone_number = utm_zone_number
            self.utm_zone_hemi = utm_zone_hemi

            # ENVI map info
            self.envi_map_info = self.get_envi_map_info()
        except Exception as e:
            logger.error(f"Error initializing GeoTransformer: {e}")
            raise

    def _calc_time_attributes(self) -> Tuple[np.floating[Any], np.floating[Any]]:
        """Calculate time duration and sampling interval of IMU data

        Returns
        -------
        t_total: float
            Total time duration of IMU data
        dt: float
            Sampling interval of IMU data
        """
        t = np.array(self.imu_data["time"])
        dt = np.mean(np.diff(t))
        t_total = len(t) * dt
        return t_total, dt

    def _calc_alongtrack_properties(
        self,
    ) -> Tuple[NDArray, NDArray, np.floating[Any], np.floating[Any]]:
        """Calculate along-track velocity, gsd, and swath length

        Returns
        -------
        v_alongtrack: NDArray
            Along-track velocity vector
        u_alongtrack: NDArray
            Along-track unit vector
        gsd_alongtrack: float
            Ground sampling distance along track
        swath_length: float
            Length of the swath along track
        """
        vx_alongtrack = (self.utm_x[-1] - self.utm_x[0]) / self.t_total
        vy_alongtrack = (self.utm_y[-1] - self.utm_y[0]) / self.t_total
        v_alongtrack = np.array((vx_alongtrack, vy_alongtrack))
        v_alongtrack_abs = np.linalg.norm(v_alongtrack)
        u_alongtrack = v_alongtrack / v_alongtrack_abs

        swath_length = self.t_total * v_alongtrack_abs
        gsd_alongtrack = self.dt * v_alongtrack_abs

        return v_alongtrack, u_alongtrack, gsd_alongtrack, swath_length

    def _calc_mean_altitude(self, assume_square_pixels: bool) -> float:
        """Calculate mean altitude of UAV during imaging

        Parameters
        ----------
        assume_square_pixels: bool
            If true, the across-track sampling distance is assumed to be equal to the
            alongtrack sampling distance. The altitude is calculated based on this and
            the number of cross-track samples. If false, the mean of the altitude values
            from the imu data is used. In both cases, the altitude offset is added.

        Returns
        -------
        altitude: float
            Mean altitude of the UAV
        """
        if assume_square_pixels:
            swath_width = self.gsd_alongtrack * self.image_shape[1]
            altitude = swath_width / (2 * np.tan(self.camera_opening_angle / 2))
        else:
            altitude = np.mean(self.imu_data["altitude"])
        return altitude + self.altitude_offset

    def _calc_acrosstrack_properties(self) -> Tuple[NDArray, float, float]:
        """Calculate cross-track unit vector, swath width and sampling distance

        Returns
        -------
        u_acrosstrack: NDArray
            Cross-track unit vector
        swath_width: float
            Width of the swath across track
        gsd_acrosstrack: float
            Ground sampling distance across track
        """
        u_acrosstrack = np.array([-self.u_alongtrack[1], self.u_alongtrack[0]])  # Rotate 90 CCW
        swath_width = 2 * self.mean_altitude * np.tan(self.camera_opening_angle / 2)
        gsd_acrosstrack = swath_width / self.image_shape[1]
        return u_acrosstrack, swath_width, gsd_acrosstrack

    def _calc_image_origin(self) -> NDArray:
        """Calculate location of image pixel (0,0) in georeferenced coordinates (x,y)

        Returns
        -------
        image_origin: NDArray
            Coordinates of the image origin
        """
        alongtrack_offset = self.mean_altitude * np.tan(self.pitch_offset) * self.u_alongtrack
        acrosstrack_offset = self.mean_altitude * np.tan(self.roll_offset) * self.u_acrosstrack
        # NOTE: Signs of cross-track elements in equation below are "flipped" because
        # UTM coordinate system is right-handed and image coordinate system is
        # left-handed. If the camera_origin is in the middle of the top line of the
        # image, u_acrosstrack points away from the image origin (line 0, sample 0).
        image_origin = (
            self.camera_origin
            - 0.5 * self.swath_width * self.u_acrosstrack  # Edge of swath
            + acrosstrack_offset
            - alongtrack_offset
        )
        return image_origin

    def _calc_image_rotation(self) -> float:
        """Calculate image rotation in degrees (zero for image origin in NW corner)

        Returns
        -------
        rotation_deg: float
            Image rotation in degrees
        """
        rotation_rad = math.atan2(self.u_alongtrack[0], -self.u_alongtrack[1])
        rotation_deg = rotation_rad * (180.0 / math.pi)
        return rotation_deg

    def _get_utm_zone(self) -> Tuple[int, str]:
        """Get UTM zone and hemisphere (North or South)

        Returns
        -------
        utm_zone_number: int
            UTM zone number
        utm_zone_hemi: str
            UTM hemisphere (North or South)
        """
        if self.utm_epsg is not None:
            utm_zone = pyproj.CRS.from_epsg(self.utm_epsg).utm_zone
            if utm_zone is None:
                raise ValueError("UTM zone undefined.")
        else:
            raise ValueError("EPSG value not set - UTM zone undefined.")
        utm_zone_number = int(utm_zone[:-1])
        if utm_zone[-1] == "N":
            utm_zone_hemi = "North"
        else:
            utm_zone_hemi = "South"
        return utm_zone_number, utm_zone_hemi

    def get_image_transform(self, ordering: str = "alphabetical") -> Tuple[float, ...]:
        """Get 6-element affine transform for image

        Parameters
        ----------
        ordering : str, {"alphabetical","worldfile"}, default "alphabetical"
            If 'alphabetical', return A,B,C,D,E,F If 'worldfile', return A,D,B,E,C,F See
            https://en.wikipedia.org/wiki/World_file

        Returns
        -------
        transform: tuple[float]
            6-element affine transform

        Raises
        ------
        ValueError
            If invalid ordering parameter is used
        """
        A, D = self.gsd_acrosstrack * self.u_acrosstrack
        B, E = self.gsd_alongtrack * self.u_alongtrack
        C, F = self.image_origin

        if ordering == "alphabetical":
            return A, B, C, D, E, F
        elif ordering == "worldfile":
            return A, D, B, E, C, F
        else:
            error_msg = f"Invalid ordering argument {ordering}"
            logger.error(error_msg)
            raise ValueError(error_msg)

    def get_envi_map_info(self) -> str:
        """Create ENVI "map info" string, including image rotation

        ENVI header files support a "map info" field which describes the geotransform
        for the image. The field has up to 11 parameters:

        1.  Projection name
        2.  Reference (tie point) pixel x location (in file coordinates)
        3.  Reference (tie point) pixel y location (in file coordinates)
        4.  Pixel easting
        5.  Pixel northing
        6.  x pixel size (on ground)
        7.  y pixel size (on ground)
        8.  Projection zone (UTM only)
        9.  North or South (UTM only)
        10. Datum
        11. Units

        NV5 / ENVI does not natively support geotransforms that are rotated. However,
        GDAL supports the use of specifying a rotation argument ("rotation=<degrees>")
        as the 11th argument (Units). This method creates a map_info string with this
        rotation syntax.

        Returns: map_info: str
            String with map info formatted in ENVI header style. Example: "{UTM, 1, 1,
            581226.666764, 7916192.56364, 5.2, 5.2,
                     4, North, WGS-84, rotation=42}"

        References
        ----------
        https://www.nv5geospatialsoftware.com/docs/ENVIHeaderFiles.html
        https://github.com/ornldaac/AVIRIS-NG_ENVI-rotatedgrid
        https://gis.stackexchange.com/questions/229952/rotate-envi-hyperspectral-imagery-with-gdal
        https://trac.osgeo.org/gdal/ticket/1778#comment:8
        https://github.com/OSGeo/gdal/blob/master/frmts/raw/envidataset.cpp#L1393
        """
        # fmt: off
        map_info = [
            "UTM",                              # Projection name
            "1",                                # Ref. x pixel sample number, 1-based
            "1",                                # Ref. y pixel sample number, 1-based
            f"{self.image_origin[0]}",          # Ref. pixel easting
            f"{self.image_origin[1]}",          # Ref. pixel northing
            f"{self.gsd_acrosstrack}",          # X pixel size (across-track GSD)
            f"{self.gsd_alongtrack}",           # Y pixel size (along-track GSD)
            f"{self.utm_zone_number}",          # UTM zone number
            f"{self.utm_zone_hemi}",            # UTM hemisphere (North or South)
            "WGS-84",                           # Datum
            f"rotation={self.rotation_deg}",    # "Units" (accepts rotation arg.)
        ]
        map_info = "{" + ", ".join(map_info) + "}"
        # fmt: on
        return map_info

    def save_image_geotransform(self, geotransform_json_path: Union[Path, str]) -> None:
        """Save geotransform and related parameters as JSON file

        The following parameters are saved to file: utm_epsg: int
            Integer EPSG code describing UTM zone (CRS)
        geotransform: tuple
            6-element tuple (a,b,c,d,e,f) with affine transform
        map_info: str
            "map info" string in ENVI header format
        gsd_alongtrack: float
            Ground sampling distance (resolution) along flight track, in meters
        gsd_acrosstrack: float
            Ground sampling distance (resolution) across flight track, in meters
        swath_length: float
            Length of image swath (along track), in meters
        swath_width: float
            Width of image swath (across track), in meters
        rotation_deg: float
            Rotation of image in degrees, clockwise, +/- 180 degrees

        Parameters
        ----------
        geotransform_json_path : Union[Path, str]
            Path to JSON file
        """
        try:
            geotransform_data = {
                "utm_epsg": self.utm_epsg,
                "geotransform": self.geotransform,
                "envi_map_info": self.envi_map_info,
                "image_origin": {"x": self.image_origin[0], "y": self.image_origin[1]},
                "gsd_alongtrack": self.gsd_alongtrack,
                "gsd_acrosstrack": self.gsd_acrosstrack,
                "swath_length": self.swath_length,
                "swath_width": self.swath_width,
                "rotation_deg": self.rotation_deg,
            }

            with open(geotransform_json_path, "w", encoding="utf-8") as write_file:
                json.dump(geotransform_data, write_file, ensure_ascii=False, indent=4)
        except Exception as e:
            logger.error(f"Error saving geotransform data: {e}")
            raise


class SimpleGeoreferencer:
    """Class for simple georeferencing of hyperspectral images using affine transforms"""

    def __init__(
        self,
        rgb_only: bool = True,
        rgb_wl: Optional[Tuple[float, float, float]] = None,
        nodata_value: int = -9999,
        reproject_to_nonrotated_transform: bool = True,
        resolution: Optional[float] = None,
    ):
        """Initialize simple georeferencer

        Parameters
        ----------
        rgb_only: bool
            Whether to only output an RGB version of the hyperspectral image. If false,
            the entire hyperspectral image is used. Note that this typically creates
            very large files that some programs (e.g. QGIS) can struggle to read.
        rgb_wl: Union[tuple[float, float, float], None]
            Wavelengths (in nm) to use for red, green and blue. If None, default values
            are used.
        nodata_value: int
            Value to insert in place of invalid pixels. Pixels which contain "all zeros"
            are considered invalid.
        reproject_to_nonrotated_transform: bool
            The simplest way to georeference a raster image is to apply an affine
            transform, which scales and rotates the raster to "place it on the map".
            However, raster images with rotated transforms ("a" and "d" are nonzero)
            cannot be merged into a single mosaic using rasterio / GDAL merge.
            Reprojecting the raster to a non-rotated transform (using the same CRS)
            allows images to be saved later. Note that with this operation, the original
            shape of the raster image is lost.
        resolution: Union[float, None]
            Resolution for reprojected raster with non-rotated transform If None, the
            mean of the along-track and across-track resolutions in the rotated raster
            is used.
        """
        self.rgb_only = rgb_only
        self.rgb_wl = rgb_wl
        self.nodata_value = nodata_value
        self.reproject_to_nonrotated_transform = reproject_to_nonrotated_transform
        self.resolution = resolution

    def georeference_hyspec_save_geotiff(
        self,
        image_path: Union[Path, str],
        geotransform_path: Union[Path, str],
        geotiff_path: Union[Path, str],
    ) -> None:
        """Georeference hyperspectral image and save as GeoTIFF

        Parameters
        ----------
        image_path: Union[Path, str]
            Path to hyperspectral image header.
        geotransform_path: Union[Path, str]
            Path to JSON file containing geotransform information.
        geotiff_path: Union[Path, str]
            Path to (output) GeoTIFF file.
        """
        try:
            # Read image, and (optional) create RGB subset
            image, wl, _ = mpu.read_envi(image_path)
            if self.rgb_only:
                if self.rgb_wl:
                    image, wl = mpu.rgb_subset_from_hsi(image, wl, rgb_target_wl=self.rgb_wl)
                else:
                    image, wl = mpu.rgb_subset_from_hsi(image, wl)

            # Insert nodata value in invalid pixels
            self._insert_image_nodata_value(image)

            # Read geotransform info and create GeoTIFF profile
            geotransform_data = mpu.read_json(geotransform_path)
            geotiff_profile = self.create_geotiff_profile(
                image,
                geotransform_parameters=geotransform_data["geotransform"],
                crs_epsg=geotransform_data["utm_epsg"],
            )

            # Write GeoTIFF file
            self.write_geotiff(
                geotiff_path,
                image,
                wl,
                geotiff_profile,
            )
        except Exception as e:
            logger.error(f"Error georeferencing hyperspectral image: {e}")
            raise

    def _insert_image_nodata_value(self, image: NDArray) -> None:
        """Insert nodata values in image (in-place)

        Parameters
        ----------
        image: NDArray
            3D image array ordered as (lines, samples, bands) Pixels where every band
            value is equal to zero are interpreted as invalid (no data).
        """
        nodata_mask = np.all(image == 0, axis=2)
        image[nodata_mask] = self.nodata_value

    def create_geotiff_profile(
        self,
        image: NDArray,
        geotransform_parameters: Union[List[float], Tuple[float, ...]],
        crs_epsg: int,
    ) -> dict:
        """Create profile for writing image as geotiff using rasterio

        Parameters
        ----------
        image: NDArray
            Path to image header (used to get image shape)
        geotransform_parameters: tuple
            6-element tuple describing affine transform from pixel coordinates to
            geographic coordinates. Ordered (A,B,C,D,E,F). See rasterio.transform.Affine
        crs_epsg: int
            EPSG code for CRS used.

        Returns
        -------
        profile: dict
            GeoTIFF profile to be used when saving GeoTIFF image.
        """

        transform = Affine(*geotransform_parameters)
        profile = DefaultGTiffProfile()
        profile.update(
            height=image.shape[0],
            width=image.shape[1],
            count=image.shape[2],
            dtype=str(image.dtype),
            crs=CRS.from_epsg(crs_epsg),
            transform=transform,
            nodata=self.nodata_value,
        )

        return profile  # type: ignore

    def calculate_non_rotated_geotiff_profile(
        self,
        src: rasterio.DatasetReader,
        resolution_decimals: int = 2,
    ) -> dict:
        """Create rasterio geotiff profile to reproject raster to non-rotated transform

        Parameters
        ----------
        src : rasterio.DatasetReader
            "Source" dataset opened in rasterio with rotated geotransform, i.e. "b" and
            "d" in geotransform are non-zero.
        resolution_decimals : int
            Number of decimals in calculated resolution for non-rotated geotiff Default
            is 2, corresponding to setting the resolution for UTM coordinates to an
            integer number of centimeters.

        Returns
        -------
        dst_profile: dict
            GeoTIFF profile for reprojection to non-rotated transform
        """
        # Calculate resolution
        if self.resolution is None:
            resolution = np.round(np.mean(src.res), decimals=resolution_decimals)
        else:
            resolution = self.resolution

        # Calculate transform and size of non-rotated raster
        non_rotated_transform, width, height = calculate_default_transform(
            src_crs=src.crs,
            dst_crs=src.crs,
            height=src.height,
            width=src.width,
            left=src.bounds.left,
            bottom=src.bounds.bottom,
            right=src.bounds.right,
            top=src.bounds.top,
            resolution=resolution,
        )
        dst_profile = src.meta.copy()
        dst_profile.update({"transform": non_rotated_transform, "width": width, "height": height})
        return dst_profile

    def write_geotiff(
        self,
        geotiff_path: Union[Path, str],
        image: NDArray,
        wavelengths: NDArray,
        geotiff_profile: dict,
    ) -> None:
        """Write image as GeoTIFF

        Parameters
        ----------
        geotiff_path : Union[Path, str]
            Path to (output) GeoTIFF file
        image : NDArray
            Image to write, shape (n_lines, n_samples, n_bands)
        wavelengths : NDArray
            Wavelengths (in nm) corresponding to each image band. The wavelengths are
            used to set the descption of each band in the GeoTIFF file.
        geotiff_profile : dict
            Dict with GeoTIFF parameters ("profile"), typically created using
            create_geotiff_profile()

        Notes
        -----
        Rasterio / GDAL requires the image to be ordered "bands first", e.g. shape
        (bands, lines, samples). However, the default used by e.g. the 'spectral'
        library is (lines, samples, bands), and this convention should be used
        consistenly to avoid bugs. This function moves the band axis directly before
        writing.
        """
        try:
            image = reshape_as_raster(image)  # Band ordering required by GeoTIFF
            band_names = [f"{wl:.3f}" for wl in wavelengths]

            if self.reproject_to_nonrotated_transform:
                # Use GDAL env. var. GDAL_PAM_ENABLED=False to hide false errors See
                # https://github.com/rasterio/rasterio/discussions/2825 for details
                with rasterio.Env(GDAL_PAM_ENABLED=False):
                    with MemoryFile() as memfile:
                        # Write rotated raster to in-memory file to open it as
                        # DatasetReader
                        with rasterio.open(memfile, "w", **geotiff_profile) as dataset:
                            for i in range(dataset.count):
                                dataset.set_band_description(i + 1, band_names[i])
                            dataset.write(image)

                        # Open in-memory rotated dataset as DatasetReader ("source")
                        with rasterio.open(memfile, "r") as src:
                            # Calculate transform and shape of non-rotated raster
                            dst_profile = self.calculate_non_rotated_geotiff_profile(src)

                            # Open output file as non-rotated destination raster dataset
                            with rasterio.open(geotiff_path, "w", **dst_profile) as dst:
                                # Loop over bands and reproject to non-rotated transform
                                for i in range(1, src.count + 1):
                                    dst.set_band_description(i, src.descriptions[i - 1])
                                    reproject(
                                        source=rasterio.band(src, i),
                                        destination=rasterio.band(dst, i),
                                        src_transform=src.transform,
                                        src_crs=src.crs,
                                        dst_transform=dst.transform,
                                        dst_crs=dst.crs,
                                        resampling=Resampling.nearest,
                                    )

            else:  # Use rotated geotransform (no reprojection needed)
                with rasterio.Env():
                    with rasterio.open(geotiff_path, "w", **geotiff_profile) as dataset:
                        if band_names is not None:
                            for i in range(dataset.count):
                                dataset.set_band_description(i + 1, band_names[i])
                        dataset.write(image)
        except Exception as e:
            logger.error(f"Error writing GeoTIFF: {e}")
            raise


class FlatTerrainOrthorectifier:
    """Line-by-line orthorectification of hyperspectral images assuming flat terrain"""

    def __init__(
        self,
        camera_opening_angle: float = 36.5,
        camera_n_pix: int = 900,
        camera_roll_offset: float = 0,
        camera_pitch_offset: float = 0,
        camera_yaw_offset: float = 0,
        camera_altitude_offset: float = 0,
        radius_of_influence: float | None = None,
        nodata_fill_value: float = np.nan,
        estimate_yaw_from_positions: bool = False,
    ):
        """Initialize orthorectifier with constants

        Parameters
        ----------
        camera_opening_angle : float, optional
            _description_, by default 36.5
        camera_n_pix : int, optional
            _description_, by default 900
        camera_roll_offset : float, optional
            Offset (in degrees) between the real roll angle and that measured by the IMU.
            If the camera points to the right (relative to IMU) the offset is positive.
        camera_pitch_offset : float, optional
            Offset (in degrees) between the real pitch angle and that measured by the IMU.
            If the camera points forwards relative to the IMU, the offset is positive.
        camera_yaw_offset : float, optional
            Offset (in degrees) between the real pitch angle and that measured by the IMU.
            If the camera is clockwise offset relative to IMU measurements, the
            offset is positive.
        camera_altitude_offset : float, optional
            Offset (in meters) between the real altitude and that measured by the IMU.
            If the altitude above ground is larger than the IMU altitude, the offset is positive.
        radius_of_influence : float | None, optional
            Radius of neigbor pixels considered for nearest-neighbor resampling
            (meters). If None, radius of influence is set to twice the ground sampling distance.
        nodata_fill_value : _type_, optional
            Which value to use for "no data" (outside swath), by default np.nan
        estimate_yaw_from_positions: bool
            Whether to estimate yaw from positions rather than using yaw measurements
            from IMU. Useful if yaw measurements are inaccurate.
        """

        self.camera_opening_angle = camera_opening_angle
        self.camera_n_pix = camera_n_pix
        self.camera_roll_offset = camera_roll_offset
        self.camera_pitch_offset = camera_pitch_offset
        self.camera_yaw_offset = camera_yaw_offset
        self.camera_altitude_offset = camera_altitude_offset

        self.radius_of_influence = radius_of_influence
        self.nodata_fill_value = nodata_fill_value
        self.estimate_yaw_from_positions = estimate_yaw_from_positions

    def _calc_pushbroom_pixel_angles(self) -> NDArray:
        """Calculate angles (rad.) of each pixel for a simple pushbroom camera model"""
        # Assume unit distance from focal point to pixel array
        # Calculate norm. dist. from center to array edge
        edge_pixel_x_norm = np.tan(np.radians(self.camera_opening_angle / 2))

        # Calculate norm. array distance from center
        pixel_x_norm = np.linspace(-edge_pixel_x_norm, edge_pixel_x_norm, self.camera_n_pix)

        # Convert pixel distances to angles (radians) and return
        return np.atan(pixel_x_norm)

    def _calc_pixel_ground_positions(
        self,
        camera_pos: NDArray,
        camera_alt: NDArray,
        pitch_angles: NDArray,
        roll_angles: NDArray,
        pixel_roll_offsets: NDArray,
        u_alongtrack: NDArray,
        u_acrosstrack: NDArray,
    ) -> NDArray:
        """Calculate ground positions of each pixel given camera positions and path unit vectors

        Parameters
        ----------
        camera_pos : NDArray, shape (n_pos,2)
            Camera x,y position (m) for each image line
        camera_alt : NDArray, shape (n_pos,)
            Camera x,y altitude (m) for each image line
        pitch_angles : NDArray, shape (n_pos,)
            Camera pitch angle (rad., positive for "nose up"), for each image line
        roll_angles : NDArray, shape (n_pos,)
            Camera roll angle (rad., positive for "right wing up"), for each image line
        pixel_roll_offsets : NDArray, shape (n_pix,)
            Pixel roll offsets (rad.) from camera center, for each pixel
        u_alongtrack : NDArray, shape (n_pos,2)
            Unit vector (x,y) pointing along-track, for each image line
        u_acrosstrack : NDArray, shape (n_pos,2)
            Unit vector (x,y) pointing across-track, for each image line

        Returns
        -------
        NDArray, shape (n_pos,n_pix,2)
            Pixel ground positions (x,y) for each image line and pixel
        """
        # Reshape to fit (n_pos,n_pix,n_coord) pattern (n_coord=2 for x,y coordinates)
        camera_pos = camera_pos.reshape(-1, 1, 2)  # shape (n_pos,1,1)
        camera_alt = camera_alt.reshape(-1, 1, 1)  # shape (n_pos,1,1)
        pitch_angles = pitch_angles.reshape(-1, 1, 1)  # shape (n_pos,1,1)
        roll_angles = roll_angles.reshape(-1, 1, 1)  # shape (n_pos,1,1)
        pixel_roll_offsets = pixel_roll_offsets.reshape(1, -1, 1)  # shape (1,n_pix,1)
        u_alongtrack = u_alongtrack.reshape(-1, 1, 2)  # shape (n_pos,1,2)
        u_acrosstrack = u_acrosstrack.reshape(-1, 1, 2)  # shape (n_pos,1,2)

        # Calculate pixel along- and acrosstrack offsets from camera center
        alongtrack_offsets = camera_alt * np.tan(pitch_angles) * u_alongtrack
        # NOTE: A positive camera roll angle ("right wing up") corresponds to an offset
        # in the opposite direction of the across-track unit vector. The sign of the
        # roll angles is therefore flipped in the calculation below.
        acrosstrack_offsets = camera_alt * np.tan(-roll_angles + pixel_roll_offsets) * u_acrosstrack

        # Calculate pixel positions
        pixel_positions = camera_pos + alongtrack_offsets + acrosstrack_offsets
        return pixel_positions

    def calc_pixel_coordinates_from_imu_data(
        self,
        imu_data: dict[str, ArrayLike],
    ) -> Tuple[NDArray, int]:
        """Calculate pixel ground coordinates from IMU data and simple pushbroom camera model

        Parameters
        ----------
        imu_data : dict[str, ArrayLike]
            IMU data with keys: 'time', 'latitude', 'longitude', 'altitude', 'pitch', 'roll'

        Returns
        -------
        pixel_utm_positions : NDArray, shape (n_pos,n_pix,2)
            Pixel ground positions (x,y in meters) for each image line and pixel
        utm_epsg : int
            EPSG code for UTM zone used.
        """
        # Convert camera lat/lon to UTM (meters)
        utm_x, utm_y, utm_epsg = mpu.convert_long_lat_to_utm(
            imu_data["longitude"], imu_data["latitude"]
        )

        # Get pixel angles
        pixel_roll_angles = self._calc_pushbroom_pixel_angles()

        # Get alongtrack and acrosstrack unit vectors
        if self.estimate_yaw_from_positions:
            time = np.array(imu_data["time"])
            u_alongtrack = calc_alongtrack_vectors_from_positions(time, utm_x, utm_y)
        else:
            yaw = np.array(imu_data["yaw"]) - np.radians(self.camera_yaw_offset)
            u_alongtrack = calc_alongtrack_vectors_from_yaw_angles(yaw)

        u_acrosstrack = calc_acrosstrack_unit_vectors(u_alongtrack)

        # Calculate pixel ground positions
        # Offset angles are converted from degrees to radians
        pixel_utm_positions = self._calc_pixel_ground_positions(
            camera_pos=np.vstack((utm_x, utm_y)).T,
            camera_alt=np.array(imu_data["altitude"]) - self.camera_altitude_offset,
            pitch_angles=np.array(imu_data["pitch"]) - np.radians(self.camera_pitch_offset),
            roll_angles=np.array(imu_data["roll"]) - np.radians(self.camera_roll_offset),
            pixel_roll_offsets=pixel_roll_angles,
            u_alongtrack=u_alongtrack,
            u_acrosstrack=u_acrosstrack,
        )

        return pixel_utm_positions, utm_epsg

    def _create_area_definition(self, pixel_utm_positions: NDArray, utm_epsg: int):
        gsd = estimate_resolution_from_pixel_coordinates(pixel_utm_positions)
        utm_x_min = np.min(pixel_utm_positions[:, :, 0])
        utm_x_max = np.max(pixel_utm_positions[:, :, 0])
        utm_y_min = np.min(pixel_utm_positions[:, :, 1])
        utm_y_max = np.max(pixel_utm_positions[:, :, 1])
        width = int((utm_x_max - utm_x_min) / gsd)
        height = int((utm_y_max - utm_y_min) / gsd)

        area_def = pyresample.geometry.AreaDefinition(
            area_id="utm_grid",
            description="UTM orthorectified area",
            proj_id="utm",
            projection=CRS.from_epsg(utm_epsg),
            width=width,
            height=height,
            area_extent=(utm_x_min, utm_y_min, utm_x_max, utm_y_max),
        )
        return area_def

    def _create_swath_definition(self, pixel_utm_coordinates, utm_epsg: int):
        # Convert UTM coordinates to lat/long
        proj = Proj(utm_epsg)
        pixel_lon, pixel_lat = proj(
            pixel_utm_coordinates[:, :, 0], pixel_utm_coordinates[:, :, 1], inverse=True
        )
        # Define swath (NOTE: MUST BE LONG/LAT)
        swath_def = pyresample.geometry.SwathDefinition(
            lons=pixel_lon,
            lats=pixel_lat,
        )
        return swath_def

    def _resample_swath_to_grid(
        self, image: NDArray, area_def: AreaDefinition, swath_def: SwathDefinition, gsd: float
    ) -> NDArray:
        """Resample image to regular grid using pyresample (kd-tree nearest neighbor)"""

        # Set radius of influence
        radius_of_influence = (
            self.radius_of_influence if self.radius_of_influence is not None else 2 * gsd
        )

        # Resample using pyresample
        result = pyresample.kd_tree.resample_nearest(
            swath_def,
            image,
            area_def,
            radius_of_influence=radius_of_influence,
            fill_value=self.nodata_fill_value,  # type: ignore
        )
        return np.array(result)  # Ensure array type

    def _create_geotiff_profile(
        self,
        image: NDArray,
        area_def: AreaDefinition,
        crs_epsg: int,
    ) -> dict:
        """Create profile for writing image as geotiff using rasterio

        Parameters
        ----------
        image: NDArray
            Path to image header (used to get image shape)
        area_def: AreaDefinition
            Pyresample AreaDefinition describing the output grid
        crs_epsg: int
            EPSG code for CRS used.

        Returns
        -------
        profile: dict
            GeoTIFF profile to be used when saving GeoTIFF image.
        """
        # Get image shape (n_lines, n_samples, n_bands)
        height, width, n_bands = image.shape

        # Build transform from area extent
        transform = from_bounds(*area_def.area_extent, width=width, height=height)

        # Create profile
        profile = DefaultGTiffProfile()
        profile.update(
            height=height,
            width=width,
            count=n_bands,
            dtype=str(image.dtype),
            crs=CRS.from_epsg(crs_epsg),
            transform=transform,
            nodata=self.nodata_fill_value,
        )

        return profile  # type: ignore

    def _save_orthorectified_image_as_geotiff(
        self,
        ortho_image: NDArray,
        wavelengths: NDArray,
        geotiff_profile: dict,
        geotiff_path: Path | str,
    ):
        """Save orthorectified image as GeoTIFF file

        Parameters
        ----------
        ortho_image : NDArray
            Orthorectified image array (lines, samples, bands)
        wavelengths : NDArray
            1D array with wavelengths for each band, shape (bands,)
        geotiff_profile : dict
            GeoTIFF profile for orthorectified image
        geotiff_path : Path | str
            Path to output GeoTIFF file
        """
        band_names = [f"{wl:.3f}" for wl in wavelengths]

        try:
            with rasterio.Env():
                with rasterio.open(geotiff_path, "w", **geotiff_profile) as dataset:
                    if band_names:
                        for i in range(dataset.count):
                            dataset.set_band_description(i + 1, band_names[i])
                    dataset.write(reshape_as_raster(ortho_image))
        except Exception as e:
            logger.error(f"Error saving orthorectified GeoTIFF: {e}")
            raise

    def orthorectify_image(
        self, image: NDArray, imu_data: dict
    ) -> Tuple[NDArray, AreaDefinition, int]:
        """Orthorectify hyperspectral image using IMU data

        Parameters
        ----------
        image : NDArray
            Hyperspectral image, shape (lines, samples, bands)
        imu_data : dict
            Dict with IMU data, with keys "time", "latitude", "longitude", "pitch",
            "roll", "yaw", and "altitude" (see ImuDataParser). Each value is a numeric
            array with length matching the number of lines in the hyperspectral image.

        Returns
        -------
        orthorectified_image: NDArray
            Image orthorectified to UTM grid.
        area_definition: AreaDefinition
            Pyresample object describing the area (extent and raster resolution)
            corresponding to the orthorectified image.
        utm_espg: int
            ESPG code for the UTM CRS used.

        """
        # Calculate pixel ground coordinates
        pixel_utm_positions, utm_epsg = self.calc_pixel_coordinates_from_imu_data(imu_data)

        # Estimate ground sampling distance (GSD)
        gsd = estimate_resolution_from_pixel_coordinates(pixel_utm_positions)

        # Create pyresample area and swath definitions
        area_def = self._create_area_definition(pixel_utm_positions, utm_epsg)
        swath_def = self._create_swath_definition(pixel_utm_positions, utm_epsg)

        # Resample image to regular grid
        ortho_image = self._resample_swath_to_grid(image, area_def, swath_def, gsd)

        return ortho_image, area_def, utm_epsg

    def orthorectify_image_file(
        self,
        image_path: Path | str,
        imu_data_path: Path | str,
        geotiff_path: Path | str,
    ):
        """Orthorectify hyperspectral image using IMU data and simple pushbroom camera model

        Parameters
        ----------
        image_path : Path | str
            Path to hyperspectral image header.
        imu_data_path : Path | str
            Path to IMU data file (JSON format).
        geotiff_path : Path | str
            Path to (output) GeoTIFF file.
        """
        # Read image
        image, wl, _ = mpu.read_envi(image_path)

        # Read IMU data
        imu_data = mpu.read_json(imu_data_path)

        # Orthorectify image
        ortho_image, area_def, utm_epsg = self.orthorectify_image(image, imu_data)

        # Create GeoTIFF profile
        geotiff_profile = self._create_geotiff_profile(ortho_image, area_def, utm_epsg)

        # Save orthorectified image as GeoTIFF
        self._save_orthorectified_image_as_geotiff(ortho_image, wl, geotiff_profile, geotiff_path)


def calc_alongtrack_vectors_from_yaw_angles(yaw: NDArray) -> NDArray:
    """Calculate alongtrack vectors based on yaw angles

    Parameters
    ----------
    yaw : NDArray
        Yaw angles in radians, shape (n_lines,)

    Returns
    -------
    u_alongtrack: NDArray
        (x,y) coordinates for alongtrack unit vectors, shape (n_lines,2)
    """
    u_alongtrack_x = np.sin(yaw)
    u_alongtrack_y = np.cos(yaw)
    return np.vstack((u_alongtrack_x, u_alongtrack_y)).T


def calc_alongtrack_vectors_from_positions(t: NDArray, x: NDArray, y: NDArray) -> NDArray:
    """Calculate heading (unit vector) from smoothed x,y positions

    Parameters
    ----------
    t : NDArray
        Time array
    x : NDArray
        x positions
    y : NDArray
        y positions

    Returns
    -------
    u_alongtrack : NDArray, shape (n_pos,2)
        Along-track unit vector at each position
    """

    # Fit smoothing splines
    sx = make_smoothing_spline(t, x)
    sy = make_smoothing_spline(t, y)

    # First derivatives (velocity components)
    dx_dt = sx.derivative()(t)
    dy_dt = sy.derivative()(t)

    # Unit vector along track
    v_alongtrack = np.vstack((dx_dt, dy_dt))
    u_alongtrack = v_alongtrack / np.linalg.norm(v_alongtrack, axis=0)

    return u_alongtrack.T


def calc_acrosstrack_unit_vectors(
    u_alongtrack: NDArray,
) -> NDArray:
    """Calculate acrosstrack unit vectors from alongtrack unit vectors

    Parameters
    ----------
    u_alongtrack : NDArray, shape (n_pos,2)
        Along-track unit vector at each position

    # Notes:
    --------
    There are two options for the direction of the acrosstrack vector, corresponding to
    clockwise or counterclockwise rotation of the alongtrack vector. For an image, the
    rows (corresponding to the y axis) are indexed from the top down. To get a vector
    that points right along the x axis (along increasing column indices in the image),
    the vector must be rotated **counterclockwise**. Rotating the opposite direction
    will result in flipping the image in the acrosstrack direction.

    """
    # Rotate 90 degrees CCW to get acrosstrack unit vectors
    u_acrosstrack = np.zeros_like(u_alongtrack)
    u_acrosstrack[:, 0] = -u_alongtrack[:, 1]
    u_acrosstrack[:, 1] = u_alongtrack[:, 0]

    return u_acrosstrack


def estimate_resolution_from_pixel_coordinates(
    pixel_utm_coordinates: NDArray,
) -> float:
    """Estimate ground sampling distance (GSD) from pixel UTM coordinates.

    Parameters
    ----------
    pixel_utm_coordinates : np.ndarray
        Array of shape (n_rows, n_cols, 2) containing UTM coordinates for each pixel.

    Returns
    -------
    gsd : float
        Estimated ground sampling distance (GSD) in meters.
    """
    # Calculate differences between adjacent pixels
    delta_x = np.diff(pixel_utm_coordinates[:, :, 0], axis=1)
    delta_y = np.diff(pixel_utm_coordinates[:, :, 1], axis=0)

    # Estimate GSD as the median of the absolute differences
    gsd_x = np.median(np.abs(delta_x))
    gsd_y = np.median(np.abs(delta_y))

    # Return the larger GSD rounded to the next significant digit
    return mpu.round_float_up(float(max(gsd_x, gsd_y)))


def envi_map_info_to_geotransform(envi_map_info: str) -> Tuple[Affine, int]:
    """Parse ENVI map info to extract affine transform and EPSG code

    This function makes several limiting assumptions: - The image uses UTM CRS - The
    geotransform is not rotated (B and D in affine transform are zero)

    Example map info: map info = "{UTM, 1.000, 1.000, 497827.4184469187,
    7454593.548431687, 0.05, 0.05,
        33, North, WGS-84, units  meters, rotation  0.000}"
    """

    map_info = envi_map_info.lstrip("{").rstrip("}").replace(" ", "").split(",")
    C = float(map_info[3])  # x origin
    F = float(map_info[4])  # y origin
    A = float(map_info[5])  # x pixel size
    E = -float(map_info[6])  # y pixel size
    B, D = 0.0, 0.0
    transform = Affine(A, B, C, D, E, F)

    utm_zone = int(map_info[7])
    utm_south = str.lower(map_info[8]) == "south"
    crs = pyproj.CRS.from_dict({"proj": "utm", "zone": utm_zone, "south": utm_south})
    epsg = crs.to_epsg()
    if epsg is None:
        logger.error("EPSG code not found for UTM zone")
        raise ValueError("EPSG code not found for UTM zone")

    return transform, epsg


def georeferenced_hyspec_to_rgb_geotiff(
    hyspec_path: Union[Path, str],
    geotiff_path: Union[Path, str],
    rgb_wl: Optional[Tuple[float, float, float]] = None,
    nodata_value: float = 0.0,
) -> None:
    """Extract RGB bands from georeferenced hyperspectral image and save as GeoTIFF

    Parameters
    ----------
    hyspec_path : Union[Path, str]
        Path to hyperspectral image header. Assumes that path to binary image is the
        same, but without .hdr suffix
    geotiff_path : Union[Path, str]
        Path to (output) GeoTIFF
    rgb_wl : tuple[float, float, float]
        Target wavelengths for RGB bands (closest available bands will be used)

    Notes
    -----
    A nodata value of zero is assumed for the hyperspectral image.
    """

    rgb_wl = (460, 550, 640) if rgb_wl is None else rgb_wl  # Default wavelengths

    hyspec_path = Path(hyspec_path)

    _, wl = mpu.read_envi_header(hyspec_path)
    wl_ind = [mpu.closest_wl_index(wl, target_wl) for target_wl in rgb_wl]
    band_names = [f"{actual_wl:.3f}" for actual_wl in wl[wl_ind]]
    with rasterio.Env():
        with rasterio.open(hyspec_path.with_suffix("")) as src:  # path to binary file
            # Read the selected bands
            bands_data = [src.read(band) for band in wl_ind]

            # Modify profile for the output file
            profile = src.meta.copy()
            profile.update(
                {
                    "count": len(wl_ind),
                    "driver": "GTiff",
                    "dtype": bands_data[0].dtype,
                    "nodata": nodata_value,
                }
            )

            # Write the bands to a new GeoTIFF file
            with rasterio.open(geotiff_path, "w", **profile) as dst:
                for i, (band_data, band_name) in enumerate(zip(bands_data, band_names), start=1):
                    dst.write(band_data, i)
                    dst.set_band_description(i, band_name)
