# Imports
import json
import logging
import subprocess
from pathlib import Path
from typing import Union

import numpy as np
import rasterio
from numpy.typing import NDArray
from rasterio.crs import CRS
from rasterio.io import MemoryFile
from rasterio.plot import reshape_as_raster
from rasterio.profiles import DefaultGTiffProfile
from rasterio.transform import Affine
from rasterio.warp import Resampling, calculate_default_transform, reproject

import massipipe.utils as mpu

# Get logger
logger = logging.getLogger(__name__)


class ImuDataParser:
    @staticmethod
    def read_lcf_file(
        lcf_file_path: Union[str, Path],
        convert_to_unix_time: bool = True,
        time_rel_to_file_start: bool = False,
    ):
        """Read location files (.lcf) generated by Resonon Airborne Hyperspectral imager

        Parameters
        ----------
        lcf_file_path: Union[str, Path]
            Path to lcf file. Usually a "sidecar" file to an hyperspectral image
            with same "base" filename.
        convert_to_unix_time: bool, default True
            Whether to convert timestamps to UNIX time, which is standard for
            many computer / sensor systems.
            Timestamps in LCF file are originally in "GPS time"
            (see https://en.wikipedia.org/wiki/Global_Positioning_System#Timekeeping)
        time_rel_to_file_start: bool, default False
            Boolean indicating if first timestamp should be subtracted from each
            timestamp, making time relative to start of file.
            If True, the value of convert_to_unix_time as no effect.


        Returns
        -------
        lcf_data:
            Dictionary with keys describing the type of data, and data
            formatted as numpy arrays. All arrays have equal length.
            The 7 types of data:
            - 'time': System time in seconds, relative to some (unknown)
            starting point. Similar to "Unix time" (seconds since January 1. 1970),
            but values indicate starting point around 1980. The values are
            usually offset to make the first timestamp equal to zero.
            See flag time_rel_to_file_start.
            - 'roll': Roll angle in radians, positive for "right wing up"
            - 'pitch': Pitch angle in radians, positive nose up
            - 'yaw': (heading) in radians, zero at due North, PI/2 at due East
            - 'longitude': Longitude in decimal degrees, negative for west longitude
            - 'latitude': Latitude in decimal degrees, negative for southern hemisphere
            - 'altitude': Altitude in meters relative to the WGS-84 ellipsiod.

        Notes:
        - The LCF file format was shared by Casey Smith at Resonon on February 16. 2021.
        - The LCF specification was inherited from Space Computer Corp.
        """
        lcf_raw = np.loadtxt(lcf_file_path)
        column_headers = [
            "time",
            "roll",
            "pitch",
            "yaw",
            "longitude",
            "latitude",
            "altitude",
        ]
        lcf_data = {header: lcf_raw[:, i] for i, header in enumerate(column_headers)}

        if convert_to_unix_time:
            lcf_data["time"] += mpu.gps2unix(lcf_data["time"][0]) - lcf_data["time"][0]

        if time_rel_to_file_start:
            lcf_data["time"] -= lcf_data["time"][0]

        return lcf_data

    @staticmethod
    def read_times_file(times_file_path: Union[Path, str], time_rel_to_file_start=True):
        """Read image line timestamps (.times) file generated by Resonon camera

        Parameters
        ----------
        times_file_path: Union[Path,str]
            Path to times file. Usually a "sidecar" file to an hyperspectral image
            with same "base" filename.
        time_rel_to_file_start: bool, default True
            Boolean indicating if times should be offset so that first
            timestamp is zero. If not, the original timestamp value is returned.

        Returns
        -------
        times:
            Numpy array containing timestamps for every line of the corresponding
            hyperspectral image. The timestamps are in units of seconds, and are
            relative to when the system started (values are usually within the
            0-10000 second range). If time_rel_to_file_start=True, the times
            are offset so that the first timestamp is zero.
            The first timestamp of the times file and the first timestamp of the
            corresponding lcf file (GPS/IMU data) are assumed to the
            recorded at exactly the same time. If both sets of timestamps are
            offset so that time is measured relative to the start of the file,
            the times can be used to calculate interpolated GPS/IMU values
            for each image line.

        """
        image_times = np.loadtxt(times_file_path)
        if time_rel_to_file_start:
            image_times = image_times - image_times[0]
        return image_times

    @staticmethod
    def interpolate_lcf_to_times(
        lcf_data: dict, image_times: NDArray, convert_to_list=True
    ) -> dict:
        """Interpolate LCF data to image line times

        Parameters
        ----------
        lcf_data : dict
            Dictionary with data read from *.lcf file
        image_times : NDArray
            Array of time stamps from *.times file
        convert_to_list : bool, default True
            Whether to convert interpolated LCF data to list
            (useful for saving data as JSON).
            If False, interpolated values in lcf_data_interp are
            formatted as NDArray.

        Returns
        -------
        lcf_data_interp: dict[list | NDArray]
            Version of lcf_data with all measured values
            interpolated to image timestamps.
        """
        lcf_data_interp = {}
        lcf_times = lcf_data["time"]

        # LCF times and image times are both measured in seconds, but with different
        # offsets. "Sync" image times so they correspond to LCF time offset:
        image_times = image_times - image_times[0] + lcf_times[0]

        for lcf_key, lcf_value in lcf_data.items():
            lcf_data_interp[lcf_key] = np.interp(image_times, lcf_times, lcf_value)
            if convert_to_list:
                lcf_data_interp[lcf_key] = lcf_data_interp[lcf_key].tolist()
        return lcf_data_interp

    def read_and_save_imu_data(
        self,
        lcf_path: Union[Path, str],
        times_path: Union[Path, str],
        json_path: Union[Path, str],
    ):
        """Parse *.lcf and *.times files and save as JSON

        Parameters
        ----------
        lcf_path : Union[Path, str]
            Path to *.lcf (IMU data) file
        times_path : Union[Path, str]
            Path to *.times (image line timestamps) file
        json_path : Union[Path, str]
            Path to output JSON file
        """
        lcf_data = self.read_lcf_file(lcf_path)
        times_data = self.read_times_file(times_path)
        lcf_data_interp = self.interpolate_lcf_to_times(lcf_data, times_data)

        with open(json_path, "w", encoding="utf-8") as write_file:
            json.dump(lcf_data_interp, write_file, ensure_ascii=False, indent=4)

    @staticmethod
    def read_imu_json_file(imu_json_path: Union[Path, str]) -> dict:
        """Read IMU data saved in JSON file

        Parameters
        ----------
        imu_json_path : Union[Path,str]
            Path to JSON file with IMU data

        Returns
        -------
        imu_data: dict
            IMU data
        """
        with open(imu_json_path, "r") as imu_file:
            imu_data = json.load(imu_file)
        return imu_data


class ImageFlightMetadata:
    """

    Attributes
    ----------
    u_alongtrack:
        Unit vector (easting, northing) pointing along flight direction
    u_crosstrack:
        Unit vector (easting, northing) pointing left relative to
        flight direction. The direction is chosen to match that of
        the image coordinate system: Origin in upper left corner,
        down (increasing line number) corresponds to positive along-track
        direction, right (increasing sample number) corresponds to
        positive cross-track direction.


    """

    def __init__(
        self,
        imu_data: dict,
        image_shape: tuple[int, ...],
        camera_opening_angle: float = 36.5,
        pitch_offset: float = 0.0,
        roll_offset: float = 0.0,
        assume_square_pixels: bool = True,
        altitude_offset: float = 0.0,
        **kwargs,
    ):
        """Initialize image flight metadata object

        Parameters
        ----------
        imu_data : dict
            Dictionary with imu_data, as formatted by ImuDataParser
        image_shape : tuple[int]
            Shape of image, typically (n_lines,n_samples,n_bands)
        camera_opening_angle : float, default 36.5
            Full opening angle of camera, in degrees.
            Corresponds to angle between rays hitting leftmost and
            rightmost pixels of image.
        pitch_offset : float, default 0.0
            How much forward the camera is pointing relative to nadir
        roll_offset : float, default 0.0
            How much to the right ("right wing up") the camera is pointing
            relative to nadir.
        assume_square_pixels : bool, default True
            Whether to assume that the original image was acquired with
            flight parameters (flight speed, frame rate, altitude)
            that would produce square pixels. If true, the altitude of the
            camera is estimated from the shape of the image and the (along-track)
            swath length. This can be useful in cases where absolute altitude
            measurement of the camera IMU is not very accurate.
        altitude_offset : float, default 0.0
            Offset added to the estimated altitude. If the UAV was higher
            in reality than that estimated by the ImageFlightMetadata
            object, add a positive altitude_offset.
        """

        # Set input attributes
        self.imu_data = imu_data
        self.image_shape = image_shape[0:2]
        self.camera_opening_angle = camera_opening_angle * (np.pi / 180)
        self.pitch_offset = pitch_offset * (np.pi / 180)
        self.roll_offset = roll_offset * (np.pi / 180)
        self.altitude_offset = altitude_offset

        # Get UTM coordinates and CRS code
        utm_x, utm_y, utm_epsg = mpu.convert_long_lat_to_utm(
            imu_data["longitude"], imu_data["latitude"]
        )
        self.utm_x = utm_x
        self.utm_y = utm_y
        self.camera_origin = np.array([utm_x[0], utm_y[0]])
        self.utm_epsg = utm_epsg

        # Time-related attributes
        t_total, dt = self._calc_time_attributes()
        self.t_total = t_total
        self.dt = dt

        # Along-track properties
        v_at, u_at, gsd_at, sl = self._calc_alongtrack_properties()
        self.v_alongtrack = v_at
        self.u_alongtrack = u_at
        self.gsd_alongtrack = gsd_at
        self.swath_length = sl

        # Altitude
        self.mean_altitude = self._calc_mean_altitude(assume_square_pixels)

        # Cross-track properties
        u_ct, sw, gsd_ct = self._calc_crosstrack_properties()
        self.u_crosstrack = u_ct
        self.swath_width = sw
        self.gsd_crosstrack = gsd_ct

        # Image origin (image transform offset)
        self.image_origin = self._calc_image_origin()

    def _calc_time_attributes(self):
        """Calculate time duration and sampling interval of IMU data"""
        t = np.array(self.imu_data["time"])
        dt = np.mean(np.diff(t))
        t_total = len(t) * dt
        return t_total, dt

    def _calc_alongtrack_properties(self):
        """Calculate along-track velocity, gsd, and swath length"""
        vx_alongtrack = (self.utm_x[-1] - self.utm_x[0]) / self.t_total
        vy_alongtrack = (self.utm_y[-1] - self.utm_y[0]) / self.t_total
        v_alongtrack = np.array((vx_alongtrack, vy_alongtrack))
        v_alongtrack_abs = np.linalg.norm(v_alongtrack)
        u_alongtrack = v_alongtrack / v_alongtrack_abs

        swath_length = self.t_total * v_alongtrack_abs
        gsd_alongtrack = self.dt * v_alongtrack_abs

        return v_alongtrack, u_alongtrack, gsd_alongtrack, swath_length

    def _calc_mean_altitude(self, assume_square_pixels):
        """Calculate mean altitude of uav during imaging

        Parameters
        ----------
        assume_square_pixels: bool
            If true, the across-track sampling distance is assumed to
            be equal to the alongtrack sampling distance. The altitude
            is calculated based on this and the number of cross-track samples.
            If false, the mean of the altitude values from the imu data
            is used. In both cases, the altitude offset is added.
        """
        if assume_square_pixels:
            swath_width = self.gsd_alongtrack * self.image_shape[1]
            altitude = swath_width / (2 * np.tan(self.camera_opening_angle / 2))
        else:
            altitude = np.mean(self.imu_data["altitude"])
        return altitude + self.altitude_offset

    def _calc_crosstrack_properties(self):
        """Calculate cross-track unit vector, swath width and sampling distance"""
        u_crosstrack = np.array(
            [-self.u_alongtrack[1], self.u_alongtrack[0]]
        )  # Rotate 90 CCW
        swath_width = 2 * self.mean_altitude * np.tan(self.camera_opening_angle / 2)
        gsd_crosstrack = swath_width / self.image_shape[1]
        return u_crosstrack, swath_width, gsd_crosstrack

    def _calc_image_origin(self):
        """Calculate location of image pixel (0,0) in georeferenced coordinates"""
        alongtrack_offset = (
            self.mean_altitude * np.tan(self.pitch_offset) * self.u_alongtrack
        )
        crosstrack_offset = (
            self.mean_altitude * np.tan(self.roll_offset) * self.u_crosstrack
        )
        # NOTE: Signs of cross-track elements in equation below are "flipped"
        # because UTM coordinate system is right-handed and image coordinate
        # system is left-handed. If the camera_origin is in the middle of the
        # top line of the image, u_crosstrack points away from the image
        # origin (line 0, sample 0).
        image_origin = (
            self.camera_origin
            - 0.5 * self.swath_width * self.u_crosstrack  # Edge of swath
            + crosstrack_offset
            - alongtrack_offset
        )
        return image_origin

    def get_image_transform(self, ordering: str = "alphabetical") -> tuple[float, ...]:
        """Get 6-element affine transform for image

        Parameters
        ----------
        ordering : str, {"alphabetical","worldfile"}, default "alphabetical"
            If 'alphabetical', return A,B,C,D,E,F
            If 'worldfile', return A,D,B,E,C,F
            See https://en.wikipedia.org/wiki/World_file

        Returns
        -------
        transform: tuple[float]
            6-element affine transform

        Raises
        ------
        ValueError
            If invalid ordering parameter is used
        """
        A, D = self.gsd_crosstrack * self.u_crosstrack
        B, E = self.gsd_alongtrack * self.u_alongtrack
        C, F = self.image_origin

        if ordering == "alphabetical":
            return A, B, C, D, E, F
        elif ordering == "worldfile":
            return A, D, B, E, C, F
        else:
            error_msg = f"Invalid ordering argument {ordering}"
            logger.error(error_msg)
            raise ValueError(error_msg)


class SimpleGeoreferencer:
    def georeference_hyspec_save_geotiff(
        self,
        image_path: Union[Path, str],
        imudata_path: Union[Path, str],
        geotiff_path: Union[Path, str],
        rgb_only: bool = True,
        nodata_value: int = -9999,
        reproject_to_nonrotated_transform: bool = True,
        **kwargs,
    ):
        """Georeference hyperspectral image and save as GeoTIFF

        Parameters
        ----------
        image_path:
            Path to hyperspectral image header.
        imudata_path:
            Path to JSON file containing IMU data.
        geotiff_path:
            Path to (output) GeoTIFF file.
        rgb_only: bool
            Whether to only output an RGB version of the hyperspectral image.
            If false, the entire hyperspectral image is used. Note that
            this typically creates very large files that some programs
            (e.g. QGIS) can struggle to read.
        nodata_value:
            Value to insert in place of invalid pixels.
            Pixels which contain "all zeros" are considered invalid.
        reproject_to_nonrotated_transform: bool
            The simplest way to georeference a raster image is to apply an affine
            transform, which scales and rotates the raster to "place it on the map".
            However, raster images with rotated transforms ("a" and "d" are nonzero)
            cannot be merged into a single mosaic using rasterio / GDAL merge.
            Reprojecting the raster to a non-rotated transform (using the same CRS)
            allows images to be saved later. Note that with this operation, the original
            shape of the raster image is lost.
        """
        image, wl, _ = mpu.read_envi(image_path)
        if rgb_only:
            image, wl = mpu.rgb_subset_from_hsi(image, wl)
        self._insert_image_nodata_value(image, nodata_value)
        geotiff_profile = self.create_geotiff_profile(
            image, imudata_path, nodata_value=nodata_value, **kwargs
        )

        self.write_geotiff(
            geotiff_path,
            image,
            wl,
            geotiff_profile,
            reproject_to_nonrotated_transform=reproject_to_nonrotated_transform,
        )

    @staticmethod
    def _insert_image_nodata_value(image: NDArray, nodata_value: float):
        """Insert nodata values in image (in-place)

        Parameters
        ----------
        image:
            3D image array ordered as (lines, samples, bands)
            Pixels where every band value is equal to zero
            are interpreted as invalid (no data).
        nodata_value:
            Value to insert in place of invalid data.
        """
        nodata_mask = np.all(image == 0, axis=2)
        image[nodata_mask] = nodata_value

    def create_geotiff_profile(
        self,
        image: NDArray,
        imudata_path: Union[Path, str],
        nodata_value: int = -9999,
        **kwargs,
    ) -> dict:
        """Create profile for writing image as geotiff using rasterio

        Parameters
        ----------
        image:
            3D image array ordered, shape (n_lines,n_samples,n_bands).
        imudata_path:
            Path to JSON file containing IMU data for image
        nodata_value: int, default -9999
            Nodata value to insert for invalid pixels

        """
        # Get flight metadata (swath size, ground sampling distance etc.)
        imu_data = ImuDataParser.read_imu_json_file(imudata_path)
        image_flight_meta = ImageFlightMetadata(imu_data, image.shape[:], **kwargs)

        # Calculate affine transform and CRS     for image
        transform = Affine(*image_flight_meta.get_image_transform())
        crs_epsg = image_flight_meta.utm_epsg

        profile = DefaultGTiffProfile()
        profile.update(
            height=image.shape[0],
            width=image.shape[1],
            count=image.shape[2],
            dtype=str(image.dtype),
            crs=CRS.from_epsg(crs_epsg),
            transform=transform,
            nodata=nodata_value,
        )

        return profile  # type: ignore

    def calculate_non_rotated_geotiff_profile(
        self, src: rasterio.DatasetReader, resolution_decimals: int = 2
    ) -> dict:
        """Create rasterio geotiff profile to reproject raster to non-rotated transform

        Parameters
        ----------
        src : rasterio.DatasetReader
            "Source" dataset opened in rasterio with rotated geotransform,
            i.e. "b" and "d" in geotransform are non-zero.
        resolution_decimals : int
            Number of decimals in calculated resolution for non-rotated geotiff
            Default is 2, corresponding to setting the resolution for UTM
            coordinates to an integer number of centimeters.

        Returns
        -------
        dst_profile: dict
            GeoTIFF profile for reprojection to non-rotated transform

        """
        gsd_mean = np.mean(np.array(src.res))
        resolution = np.round(gsd_mean, decimals=resolution_decimals)

        non_rotated_transform, width, height = calculate_default_transform(
            src_crs=src.crs,
            dst_crs=src.crs,
            height=src.height,
            width=src.width,
            left=src.bounds.left,
            bottom=src.bounds.bottom,
            right=src.bounds.right,
            top=src.bounds.top,
            resolution=resolution,
        )
        dst_profile = src.meta.copy()
        dst_profile.update(
            {"transform": non_rotated_transform, "width": width, "height": height}
        )
        return dst_profile

    def write_geotiff(
        self,
        geotiff_path: Union[Path, str],
        image: NDArray,
        wavelengths: NDArray,
        geotiff_profile: dict,
        reproject_to_nonrotated_transform: bool = True,
    ):
        """Write image as GeoTIFF

        Parameters
        ----------
        geotiff_path : Union[Path, str]
            Path to (output) GeoTIFF file
        image : NDArray
            Image to write, shape (n_lines, n_samples, n_bands)
        wavelengths : NDArray
            Wavelengths (in nm) corresponding to each image band.
            The wavelengths are used to set the descption of each band
            in the GeoTIFF file.
        geotiff_profile : dict
            Dict with GeoTIFF parameters ("profile"), typically created using
            create_geotiff_profile()
        reproject_to_nonrotated_transform: bool, default True
            Whether to reproject raster image to a non-rotated transform
            before saving as GeoTIFF.

        Notes
        -----
        Rasterio / GDAL requires the image to be ordered "bands first", e.g. shape
        (bands, lines, samples). However, the default used by e.g. the 'spectral'
        library is (lines, samples, bands), and this convention should be used
        consistenly to avoid bugs. This function moves the band axis directly before
        writing.
        """
        image = reshape_as_raster(image)  # Band ordering required by GeoTIFF
        band_names = [f"{wl:.3f}" for wl in wavelengths]

        if reproject_to_nonrotated_transform:
            # Use GDAL env. var. GDAL_PAM_ENABLED=False to hide false errors
            # See https://github.com/rasterio/rasterio/discussions/2825 for details
            with rasterio.Env(GDAL_PAM_ENABLED=False):
                with MemoryFile() as memfile:
                    # Write rotated raster to in-memory file to open it as DatasetReader
                    with rasterio.open(memfile, "w", **geotiff_profile) as dataset:
                        for i in range(dataset.count):
                            dataset.set_band_description(i + 1, band_names[i])
                        dataset.write(image)

                    # Open in-memory rotated dataset as DatasetReader ("source")
                    with rasterio.open(memfile, "r") as src:
                        # Calculate transform and shape of non-rotated raster
                        dst_profile = self.calculate_non_rotated_geotiff_profile(src)

                        # Open output file as non-rotated destination raster dataset
                        with rasterio.open(geotiff_path, "w", **dst_profile) as dst:
                            # Loop over bands and reproject to non-rotated transform
                            for i in range(1, src.count + 1):
                                dst.set_band_description(i, src.descriptions[i - 1])
                                reproject(
                                    source=rasterio.band(src, i),
                                    destination=rasterio.band(dst, i),
                                    src_transform=src.transform,
                                    src_crs=src.crs,
                                    dst_transform=dst.transform,
                                    dst_crs=dst.crs,
                                    resampling=Resampling.nearest,
                                )

        else:  # Use rotated geotransform (no reprojection needed)
            with rasterio.Env():
                with rasterio.open(geotiff_path, "w", **geotiff_profile) as dataset:
                    if band_names is not None:
                        for i in range(dataset.count):
                            dataset.set_band_description(i + 1, band_names[i])
                    dataset.write(image)

    # @staticmethod
    # def update_image_file_transform(
    #     geotiff_path: Union[Path, str], imu_data_path: Union[Path, str], **kwargs
    # ):
    #     """Update the affine transform of an image

    #     Parameters
    #     ----------
    #     geotiff_path:
    #         Path to existing GeoTIFF file.
    #     imu_data_path:
    #         Path to JSON file with IMU data.
    #     **kwargs:
    #         Keyword arguments are passed along to create an ImageFlightMetadata object
    #         Options include e.g. 'altitude_offset'. This can be useful in case
    #         the shape of the existing GeoTIFF indicates that some adjustments
    #         should be made to the image transform (which can be re-generated using
    #         an ImageFlightMetadata object).

    #     References:
    #     -----------
    #     - https://rasterio.readthedocs.io/en/latest/api/rasterio.rio.edit_info.html
    #     """
    #     imu_data = ImuDataParser.read_imu_json_file(imu_data_path)
    #     with rasterio.open(geotiff_path, "r") as dataset:
    #         im_width = dataset.width
    #         im_height = dataset.height
    #     image_flight_meta = ImageFlightMetadata(
    #         imu_data, image_shape=(im_height, im_width), **kwargs
    #     )
    #     new_transform = image_flight_meta.get_image_transform()
    #     rio_cmd = [
    #         "rio",
    #         "edit-info",
    #         "--transform",
    #         str(list(new_transform)),
    #         str(geotiff_path),
    #     ]
    #     subprocess.run(rio_cmd)
