"""Module for georeferencing hyperspectral imagery and processing IMU data.
Provides classes and methods to parse IMU files, compute geospatial transforms,
and generate georeferenced outputs such as GeoTIFFs.
"""

# Imports
import json
import logging
import math
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import pyproj
import rasterio
from numpy.typing import NDArray
from rasterio.crs import CRS
from rasterio.io import MemoryFile
from rasterio.plot import reshape_as_raster
from rasterio.profiles import DefaultGTiffProfile
from rasterio.transform import Affine
from rasterio.warp import Resampling, calculate_default_transform, reproject

import massipipe.utils as mpu

# Get logger
logger = logging.getLogger(__name__)


class ImuDataParser:
    """
    ImuDataParser is a utility class for parsing and processing IMU (Inertial
    Measurement Unit) data files generated by Resonon Airborne Hyperspectral imagers. It
    provides methods to read location files (.lcf), image line timestamps (.times)
    files, and interpolate the IMU data to match the image timestamps.

    Methods
    -------
    read_lcf_file(lcf_file_path: Union[str, Path], convert_to_unix_time: bool = True,
    time_rel_to_file_start: bool = False) -> Dict[str, NDArray]
        Reads location files (.lcf) generated by Resonon Airborne Hyperspectral imager
        and returns the data as a dictionary of numpy arrays.
    read_times_file(times_file_path: Union[Path, str], time_rel_to_file_start: bool =
    True) -> NDArray
        Reads image line timestamps (.times) file generated by Resonon camera and
        returns the data as a numpy array.
    interpolate_lcf_to_times(lcf_data: Dict[str, NDArray], image_times: NDArray,
    convert_to_list: bool = True) -> Dict[str, Union[List, NDArray]]
        Interpolates LCF data to image line times and returns the interpolated data as a
        dictionary.
    read_and_save_imu_data(self, lcf_path: Union[Path, str], times_path: Union[Path,
    str], json_path: Union[Path, str]) -> None
        Parses *.lcf and *.times files, interpolates the data, and saves it as a JSON
        file.
    """

    @staticmethod
    def read_lcf_file(
        lcf_file_path: Union[str, Path],
        convert_to_unix_time: bool = True,
        time_rel_to_file_start: bool = False,
    ) -> Dict[str, NDArray]:
        """Read location files (.lcf) generated by Resonon Airborne Hyperspectral imager

        Parameters
        ----------
        lcf_file_path: Union[str, Path]
            Path to lcf file. Usually a "sidecar" file to an hyperspectral image with
            same "base" filename.
        convert_to_unix_time: bool, default True
            Whether to convert timestamps to UNIX time, which is standard for many
            computer / sensor systems. Timestamps in LCF file are originally in "GPS
            time" (see
            https://en.wikipedia.org/wiki/Global_Positioning_System#Timekeeping)
        time_rel_to_file_start: bool, default False
            Boolean indicating if first timestamp should be subtracted from each
            timestamp, making time relative to start of file. If True, the value of
            convert_to_unix_time as no effect.

        Returns
        -------
        lcf_data: Dict[str, NDArray]
            Dictionary with keys describing the type of data, and data formatted as
            numpy arrays. All arrays have equal length. The 7 types of data (keys) are:
            'time': System time in seconds (GPS time). 'roll': Roll angle in
            radians, positive for "right wing up". 'pitch': Pitch angle in radians,
            positive nose up. 'yaw': (heading) in radians, zero at due North, PI/2 at
            due East. 'longitude': Longitude in decimal degrees, negative for west
            longitude. 'latitude': Latitude in decimal degrees, negative for southern
            hemisphere. 'altitude': Altitude in meters relative to the WGS-84
            ellipsiod.

        Notes
        -----
        The LCF file format was shared by Casey Smith at Resonon on February 16. 2021.
        The LCF specification was inherited from Space Computer Corp.
        """
        try:
            lcf_raw = np.loadtxt(lcf_file_path)
        except Exception as e:
            logger.error(f"Error reading LCF file {lcf_file_path}: {e}")
            raise
        column_headers = [
            "time",
            "roll",
            "pitch",
            "yaw",
            "longitude",
            "latitude",
            "altitude",
        ]
        lcf_data = {header: lcf_raw[:, i] for i, header in enumerate(column_headers)}

        if convert_to_unix_time:
            lcf_data["time"] += mpu.gps2unix(lcf_data["time"][0]) - lcf_data["time"][0]

        if time_rel_to_file_start:
            lcf_data["time"] -= lcf_data["time"][0]

        return lcf_data

    @staticmethod
    def read_times_file(
        times_file_path: Union[Path, str], time_rel_to_file_start: bool = True
    ) -> NDArray:
        """Read image line timestamps (.times) file generated by Resonon camera

        Parameters
        ----------
        times_file_path: Union[Path,str]
            Path to times file. Usually a "sidecar" file to an hyperspectral image with
            same "base" filename.
        time_rel_to_file_start: bool, default True
            Boolean indicating if times should be offset so that first timestamp is
            zero. If not, the original timestamp value is returned.

        Returns
        -------
        times: NDArray
            Numpy array containing timestamps for every line of the corresponding
            hyperspectral image. The timestamps are in units of seconds, and are
            relative to when the system started (values are usually within the 0-10000
            second range). If time_rel_to_file_start=True, the times are offset so that
            the first timestamp is zero. The first timestamp of the times file and the
            first timestamp of the corresponding lcf file (GPS/IMU data) are assumed to
            the recorded at exactly the same time. If both sets of timestamps are offset
            so that time is measured relative to the start of the file, the times can be
            used to calculate interpolated GPS/IMU values for each image line.
        """
        try:
            image_times = np.loadtxt(times_file_path)
        except Exception as e:
            logger.error(f"Error reading times file {times_file_path}: {e}")
            raise
        if time_rel_to_file_start:
            image_times = image_times - image_times[0]
        return image_times

    @staticmethod
    def interpolate_lcf_to_times(
        lcf_data: Dict[str, NDArray], image_times: NDArray, convert_to_list: bool = True
    ) -> Dict[str, Union[List, NDArray]]:
        """Interpolate LCF data to image line times

        Parameters
        ----------
        lcf_data : dict
            Dictionary with data read from *.lcf file
        image_times : NDArray
            Array of time stamps from *.times file
        convert_to_list : bool, default True
            Whether to convert interpolated LCF data to list (useful for saving data as
            JSON). If False, interpolated values in lcf_data_interp are formatted as
            NDArray.

        Returns
        -------
        lcf_data_interp: dict[list | NDArray]
            Version of lcf_data with all measured values interpolated to image
            timestamps.
        """
        lcf_data_interp = {}
        lcf_times = lcf_data["time"]

        # LCF times and image times are both measured in seconds, but with different
        # offsets. "Sync" image times so they correspond to LCF time offset:
        image_times = image_times - image_times[0] + lcf_times[0]

        for lcf_key, lcf_value in lcf_data.items():
            lcf_data_interp[lcf_key] = np.interp(image_times, lcf_times, lcf_value)
            if convert_to_list:
                lcf_data_interp[lcf_key] = lcf_data_interp[lcf_key].tolist()
        return lcf_data_interp

    def read_and_save_imu_data(
        self,
        lcf_path: Union[Path, str],
        times_path: Union[Path, str],
        json_path: Union[Path, str],
    ) -> None:
        """Parse *.lcf and *.times files and save as JSON

        Parameters
        ----------
        lcf_path : Union[Path, str]
            Path to *.lcf (IMU data) file
        times_path : Union[Path, str]
            Path to *.times (image line timestamps) file
        json_path : Union[Path, str]
            Path to output JSON file
        """
        try:
            lcf_data = self.read_lcf_file(lcf_path)
            times_data = self.read_times_file(times_path)
            lcf_data_interp = self.interpolate_lcf_to_times(lcf_data, times_data)

            with open(json_path, "w", encoding="utf-8") as write_file:
                json.dump(lcf_data_interp, write_file, ensure_ascii=False, indent=4)
        except Exception as e:
            logger.error(f"Error processing IMU data: {e}")
            raise


class ImuGeoTransformer:
    """
    Class for calculating affine geotransform based on IMU data and image shape.

    Attributes
    ----------
    camera_opening_angle : float
        Full opening angle of camera, in radians.
    pitch_offset : float
        Forward pointing angle of the camera relative to nadir, in radians.
    roll_offset : float
        Right pointing angle of the camera relative to nadir, in radians.
    altitude_offset : float
        Offset added to the estimated altitude.
    utm_x_offset : float
        Offset in the UTM x-coordinate.
    utm_y_offset : float
        Offset in the UTM y-coordinate.
    imu_data : dict
        IMU data loaded from JSON file.
    image_shape : tuple
        Shape of the hyperspectral image.
    utm_x : float
        UTM x-coordinate of the IMU data.
    utm_y : float
        UTM y-coordinate of the IMU data.
    camera_origin : NDArray
        Origin of the camera in UTM coordinates.
    t_total : float
        Total time duration of IMU data.
    dt : float
        Sampling interval of IMU data.
    v_alongtrack : NDArray
        Along-track velocity vector, in m/s.
    u_alongtrack: NDArray
        Unit vector (easting, northing) pointing along flight direction
    gsd_alongtrack : float
        Ground sampling distance along track.
    swath_length : float
        Length of the swath along track.
    mean_altitude : float
        Mean altitude of the UAV during imaging.
    u_acrosstrack: NDArray
        Unit vector (easting, northing) pointing left relative to flight direction. The
        direction is chosen to match that of the image coordinate system: Origin in
        upper left corner, down (increasing line number) corresponds to positive
        along-track direction, right (increasing sample number) corresponds to positive
        cross-track direction.
    swath_width : float
        Width of the swath across track.
    gsd_acrosstrack : float
        Ground sampling distance across track.
    image_origin : NDArray
        Coordinates of the image origin.
    geotransform : tuple
        6-element affine transform for the image.
    rotation_deg : float
        Image rotation in degrees.
    utm_zone_number : int
        UTM zone number.
    utm_zone_hemi : str
        UTM hemisphere (North or South).
    envi_map_info : str
        ENVI "map info" string, including image rotation.

    Methods
    -------
    __init__(imu_data_path: Union[Path, str], image_header_path: Union[Path, str],
    camera_opening_angle: Optional[float] = None, pitch_offset: Optional[float] = None,
    roll_offset: Optional[float] = None, altitude_offset: Optional[float] = None,
    utm_x_offset: Optional[float] = None, utm_y_offset: Optional[float] = None,
    assume_square_pixels: Optional[bool] = True)
        Initialize image flight metadata object.
    get_image_transform(ordering: str = "alphabetical") -> Tuple[float, ...]
        Get 6-element affine transform for image.
    get_envi_map_info() -> str
        Create ENVI "map info" string, including image rotation.
    save_image_geotransform(geotransform_json_path: Union[Path, str]) -> None
        Save geotransform and related parameters as JSON file.

    """

    def __init__(
        self,
        imu_data_path: Union[Path, str],
        image_header_path: Union[Path, str],
        camera_opening_angle: Optional[float] = None,
        pitch_offset: Optional[float] = None,
        roll_offset: Optional[float] = None,
        altitude_offset: Optional[float] = None,
        utm_x_offset: Optional[float] = None,
        utm_y_offset: Optional[float] = None,
        assume_square_pixels: Optional[bool] = True,
    ):
        """Initialize image flight metadata object

        Parameters
        ----------
        imu_data_path : Union[Path, str]
            Path to JSON file with IMU data
        image_header_path : Union[Path, str]
            Path to header for hyperspectral image
        camera_opening_angle : float, default 36.5
            Full opening angle of camera, in degrees. Corresponds to angle between rays
            hitting leftmost and rightmost pixels of image.
        pitch_offset : float, default 0.0
            How much forward the camera is pointing relative to nadir (degrees)
        roll_offset : float, default 0.0
            How much to the right ("right wing up") the camera is pointing relative to
            nadir (degrees).
        altitude_offset : float, default 0.0
            Offset added to the estimated altitude. If the UAV was higher in reality
            than that estimated by the GeoTransformer object, add a positive
            altitude_offset.
        utm_x_offset, utm_y_offset: float, default 0.0
            How far from the real position the IMU data position is, measured in meters.
            If the IMU data is too far east, utm_x_offset is positive. If the IMU data
            is too far north, utm_y_offset is positive. The offset is assumed to be
            constant across a dataset.
        assume_square_pixels : bool, default True
            Whether to assume that the original image was acquired with flight
            parameters (flight speed, frame rate, altitude) that would produce square
            pixels. If true, the altitude of the camera is estimated from the shape of
            the image and the (along-track) swath length. This can be useful in cases
            where absolute altitude measurement of the camera IMU is not very accurate.
        """

        # Set default values
        camera_opening_angle = camera_opening_angle if camera_opening_angle else 36.5
        pitch_offset = pitch_offset if pitch_offset else 0.0
        roll_offset = roll_offset if roll_offset else 0.0
        altitude_offset = altitude_offset if altitude_offset else 0.0
        utm_x_offset = utm_x_offset if utm_x_offset else 0.0
        utm_y_offset = utm_y_offset if utm_y_offset else 0.0
        assume_square_pixels = (
            True if assume_square_pixels or (assume_square_pixels is None) else False
        )

        # Set attributes, converting degrees to radians
        self.camera_opening_angle = camera_opening_angle * (np.pi / 180)
        self.pitch_offset = pitch_offset * (np.pi / 180)
        self.roll_offset = roll_offset * (np.pi / 180)
        self.altitude_offset = altitude_offset
        self.utm_x_offset = utm_x_offset
        self.utm_y_offset = utm_y_offset

        try:
            # Get imu data and image shape from files
            self.imu_data = mpu.read_json(imu_data_path)
            self.image_shape = mpu.get_image_shape(image_header_path)

            # Get UTM coordinates and CRS code
            self.utm_x, self.utm_y, self.utm_epsg = mpu.convert_long_lat_to_utm(
                self.imu_data["longitude"], self.imu_data["latitude"]
            )
            self.utm_x -= self.utm_x_offset
            self.utm_y -= self.utm_y_offset
            self.camera_origin = np.array([self.utm_x[0], self.utm_y[0]])

            # Time-related attributes
            t_total, dt = self._calc_time_attributes()
            self.t_total = t_total
            self.dt = dt

            # Along-track properties
            v_at, u_at, gsd_at, sl = self._calc_alongtrack_properties()
            self.v_alongtrack = v_at
            self.u_alongtrack = u_at
            self.gsd_alongtrack = gsd_at
            self.swath_length = sl

            # Altitude
            self.mean_altitude = self._calc_mean_altitude(assume_square_pixels)

            # Cross-track properties
            u_ct, sw, gsd_ct = self._calc_acrosstrack_properties()
            self.u_acrosstrack = u_ct
            self.swath_width = sw
            self.gsd_acrosstrack = gsd_ct

            # Image origin (image transform offset)
            self.image_origin = self._calc_image_origin()

            # Affine transform
            self.geotransform = self.get_image_transform(ordering="alphabetical")

            # Image rotation (degrees)
            self.rotation_deg = self._calc_image_rotation()

            # UTM zone
            utm_zone_number, utm_zone_hemi = self._get_utm_zone()
            self.utm_zone_number = utm_zone_number
            self.utm_zone_hemi = utm_zone_hemi

            # ENVI map info
            self.envi_map_info = self.get_envi_map_info()
        except Exception as e:
            logger.error(f"Error initializing GeoTransformer: {e}")
            raise

    def _calc_time_attributes(self) -> Tuple[np.floating[Any], np.floating[Any]]:
        """Calculate time duration and sampling interval of IMU data

        Returns
        -------
        t_total: float
            Total time duration of IMU data
        dt: float
            Sampling interval of IMU data
        """
        t = np.array(self.imu_data["time"])
        dt = np.mean(np.diff(t))
        t_total = len(t) * dt
        return t_total, dt

    def _calc_alongtrack_properties(
        self,
    ) -> Tuple[NDArray, NDArray, np.floating[Any], np.floating[Any]]:
        """Calculate along-track velocity, gsd, and swath length

        Returns
        -------
        v_alongtrack: NDArray
            Along-track velocity vector
        u_alongtrack: NDArray
            Along-track unit vector
        gsd_alongtrack: float
            Ground sampling distance along track
        swath_length: float
            Length of the swath along track
        """
        vx_alongtrack = (self.utm_x[-1] - self.utm_x[0]) / self.t_total
        vy_alongtrack = (self.utm_y[-1] - self.utm_y[0]) / self.t_total
        v_alongtrack = np.array((vx_alongtrack, vy_alongtrack))
        v_alongtrack_abs = np.linalg.norm(v_alongtrack)
        u_alongtrack = v_alongtrack / v_alongtrack_abs

        swath_length = self.t_total * v_alongtrack_abs
        gsd_alongtrack = self.dt * v_alongtrack_abs

        return v_alongtrack, u_alongtrack, gsd_alongtrack, swath_length

    def _calc_mean_altitude(self, assume_square_pixels: bool) -> float:
        """Calculate mean altitude of UAV during imaging

        Parameters
        ----------
        assume_square_pixels: bool
            If true, the across-track sampling distance is assumed to be equal to the
            alongtrack sampling distance. The altitude is calculated based on this and
            the number of cross-track samples. If false, the mean of the altitude values
            from the imu data is used. In both cases, the altitude offset is added.

        Returns
        -------
        altitude: float
            Mean altitude of the UAV
        """
        if assume_square_pixels:
            swath_width = self.gsd_alongtrack * self.image_shape[1]
            altitude = swath_width / (2 * np.tan(self.camera_opening_angle / 2))
        else:
            altitude = np.mean(self.imu_data["altitude"])
        return altitude + self.altitude_offset

    def _calc_acrosstrack_properties(self) -> Tuple[NDArray, float, float]:
        """Calculate cross-track unit vector, swath width and sampling distance

        Returns
        -------
        u_acrosstrack: NDArray
            Cross-track unit vector
        swath_width: float
            Width of the swath across track
        gsd_acrosstrack: float
            Ground sampling distance across track
        """
        u_acrosstrack = np.array([-self.u_alongtrack[1], self.u_alongtrack[0]])  # Rotate 90 CCW
        swath_width = 2 * self.mean_altitude * np.tan(self.camera_opening_angle / 2)
        gsd_acrosstrack = swath_width / self.image_shape[1]
        return u_acrosstrack, swath_width, gsd_acrosstrack

    def _calc_image_origin(self) -> NDArray:
        """Calculate location of image pixel (0,0) in georeferenced coordinates (x,y)

        Returns
        -------
        image_origin: NDArray
            Coordinates of the image origin
        """
        alongtrack_offset = self.mean_altitude * np.tan(self.pitch_offset) * self.u_alongtrack
        acrosstrack_offset = self.mean_altitude * np.tan(self.roll_offset) * self.u_acrosstrack
        # NOTE: Signs of cross-track elements in equation below are "flipped" because
        # UTM coordinate system is right-handed and image coordinate system is
        # left-handed. If the camera_origin is in the middle of the top line of the
        # image, u_acrosstrack points away from the image origin (line 0, sample 0).
        image_origin = (
            self.camera_origin
            - 0.5 * self.swath_width * self.u_acrosstrack  # Edge of swath
            + acrosstrack_offset
            - alongtrack_offset
        )
        return image_origin

    def _calc_image_rotation(self) -> float:
        """Calculate image rotation in degrees (zero for image origin in NW corner)

        Returns
        -------
        rotation_deg: float
            Image rotation in degrees
        """
        rotation_rad = math.atan2(self.u_alongtrack[0], -self.u_alongtrack[1])
        rotation_deg = rotation_rad * (180.0 / math.pi)
        return rotation_deg

    def _get_utm_zone(self) -> Tuple[int, str]:
        """Get UTM zone and hemisphere (North or South)

        Returns
        -------
        utm_zone_number: int
            UTM zone number
        utm_zone_hemi: str
            UTM hemisphere (North or South)
        """
        if self.utm_epsg is not None:
            utm_zone = pyproj.CRS.from_epsg(self.utm_epsg).utm_zone
            assert utm_zone is not None
        else:
            raise ValueError("EPSG value not set - UTM zone undefined.")
        utm_zone_number = int(utm_zone[:-1])
        if utm_zone[-1] == "N":
            utm_zone_hemi = "North"
        else:
            utm_zone_hemi = "South"
        return utm_zone_number, utm_zone_hemi

    def get_image_transform(self, ordering: str = "alphabetical") -> Tuple[float, ...]:
        """Get 6-element affine transform for image

        Parameters
        ----------
        ordering : str, {"alphabetical","worldfile"}, default "alphabetical"
            If 'alphabetical', return A,B,C,D,E,F If 'worldfile', return A,D,B,E,C,F See
            https://en.wikipedia.org/wiki/World_file

        Returns
        -------
        transform: tuple[float]
            6-element affine transform

        Raises
        ------
        ValueError
            If invalid ordering parameter is used
        """
        A, D = self.gsd_acrosstrack * self.u_acrosstrack
        B, E = self.gsd_alongtrack * self.u_alongtrack
        C, F = self.image_origin

        if ordering == "alphabetical":
            return A, B, C, D, E, F
        elif ordering == "worldfile":
            return A, D, B, E, C, F
        else:
            error_msg = f"Invalid ordering argument {ordering}"
            logger.error(error_msg)
            raise ValueError(error_msg)

    def get_envi_map_info(self) -> str:
        """Create ENVI "map info" string, including image rotation

        ENVI header files support a "map info" field which describes the geotransform
        for the image. The field has up to 11 parameters:

        1.  Projection name
        2.  Reference (tie point) pixel x location (in file coordinates)
        3.  Reference (tie point) pixel y location (in file coordinates)
        4.  Pixel easting
        5.  Pixel northing
        6.  x pixel size (on ground)
        7.  y pixel size (on ground)
        8.  Projection zone (UTM only)
        9.  North or South (UTM only)
        10. Datum
        11. Units

        NV5 / ENVI does not natively support geotransforms that are rotated. However,
        GDAL supports the use of specifying a rotation argument ("rotation=<degrees>")
        as the 11th argument (Units). This method creates a map_info string with this
        rotation syntax.

        Returns: map_info: str
            String with map info formatted in ENVI header style. Example: "{UTM, 1, 1,
            581226.666764, 7916192.56364, 5.2, 5.2,
                     4, North, WGS-84, rotation=42}"

        References
        ----------
        https://www.nv5geospatialsoftware.com/docs/ENVIHeaderFiles.html
        https://github.com/ornldaac/AVIRIS-NG_ENVI-rotatedgrid
        https://gis.stackexchange.com/questions/229952/rotate-envi-hyperspectral-imagery-with-gdal
        https://trac.osgeo.org/gdal/ticket/1778#comment:8
        https://github.com/OSGeo/gdal/blob/master/frmts/raw/envidataset.cpp#L1393
        """
        # fmt: off
        map_info = [
            "UTM",                              # Projection name
            "1",                                # Ref. x pixel sample number, 1-based
            "1",                                # Ref. y pixel sample number, 1-based
            f"{self.image_origin[0]}",          # Ref. pixel easting
            f"{self.image_origin[1]}",          # Ref. pixel northing
            f"{self.gsd_acrosstrack}",          # X pixel size (across-track GSD)
            f"{self.gsd_alongtrack}",           # Y pixel size (along-track GSD)
            f"{self.utm_zone_number}",          # UTM zone number
            f"{self.utm_zone_hemi}",            # UTM hemisphere (North or South)
            "WGS-84",                           # Datum
            f"rotation={self.rotation_deg}",    # "Units" (accepts rotation arg.)
        ]
        map_info = "{" + ", ".join(map_info) + "}"
        # fmt: on
        return map_info

    def save_image_geotransform(self, geotransform_json_path: Union[Path, str]) -> None:
        """Save geotransform and related parameters as JSON file

        The following parameters are saved to file: utm_epsg: int
            Integer EPSG code describing UTM zone (CRS)
        geotransform: tuple
            6-element tuple (a,b,c,d,e,f) with affine transform
        map_info: str
            "map info" string in ENVI header format
        gsd_alongtrack: float
            Ground sampling distance (resolution) along flight track, in meters
        gsd_acrosstrack: float
            Ground sampling distance (resolution) across flight track, in meters
        swath_length: float
            Length of image swath (along track), in meters
        swath_width: float
            Width of image swath (across track), in meters
        rotation_deg: float
            Rotation of image in degrees, clockwise, +/- 180 degrees

        Parameters
        ----------
        geotransform_json_path : Union[Path, str]
            Path to JSON file
        """
        try:
            geotransform_data = {
                "utm_epsg": self.utm_epsg,
                "geotransform": self.geotransform,
                "envi_map_info": self.envi_map_info,
                "image_origin": {"x": self.image_origin[0], "y": self.image_origin[1]},
                "gsd_alongtrack": self.gsd_alongtrack,
                "gsd_acrosstrack": self.gsd_acrosstrack,
                "swath_length": self.swath_length,
                "swath_width": self.swath_width,
                "rotation_deg": self.rotation_deg,
            }

            with open(geotransform_json_path, "w", encoding="utf-8") as write_file:
                json.dump(geotransform_data, write_file, ensure_ascii=False, indent=4)
        except Exception as e:
            logger.error(f"Error saving geotransform data: {e}")
            raise


class SimpleGeoreferencer:
    """Class for simple georeferencing of hyperspectral images using affine transforms"""

    def __init__(
        self,
        rgb_only: bool = True,
        rgb_wl: Optional[Tuple[float, float, float]] = None,
        nodata_value: int = -9999,
        reproject_to_nonrotated_transform: bool = True,
        resolution: Optional[float] = None,
    ):
        """Initialize simple georeferencer

        Parameters
        ----------
        rgb_only: bool
            Whether to only output an RGB version of the hyperspectral image. If false,
            the entire hyperspectral image is used. Note that this typically creates
            very large files that some programs (e.g. QGIS) can struggle to read.
        rgb_wl: Union[tuple[float, float, float], None]
            Wavelengths (in nm) to use for red, green and blue. If None, default values
            are used.
        nodata_value: int
            Value to insert in place of invalid pixels. Pixels which contain "all zeros"
            are considered invalid.
        reproject_to_nonrotated_transform: bool
            The simplest way to georeference a raster image is to apply an affine
            transform, which scales and rotates the raster to "place it on the map".
            However, raster images with rotated transforms ("a" and "d" are nonzero)
            cannot be merged into a single mosaic using rasterio / GDAL merge.
            Reprojecting the raster to a non-rotated transform (using the same CRS)
            allows images to be saved later. Note that with this operation, the original
            shape of the raster image is lost.
        resolution: Union[float, None]
            Resolution for reprojected raster with non-rotated transform If None, the
            mean of the along-track and across-track resolutions in the rotated raster
            is used.
        """
        self.rgb_only = rgb_only
        self.rgb_wl = rgb_wl
        self.nodata_value = nodata_value
        self.reproject_to_nonrotated_transform = reproject_to_nonrotated_transform
        self.resolution = resolution

    def georeference_hyspec_save_geotiff(
        self,
        image_path: Union[Path, str],
        geotransform_path: Union[Path, str],
        geotiff_path: Union[Path, str],
    ) -> None:
        """Georeference hyperspectral image and save as GeoTIFF

        Parameters
        ----------
        image_path: Union[Path, str]
            Path to hyperspectral image header.
        geotransform_path: Union[Path, str]
            Path to JSON file containing geotransform information.
        geotiff_path: Union[Path, str]
            Path to (output) GeoTIFF file.
        """
        try:
            # Read image, and (optional) create RGB subset
            image, wl, _ = mpu.read_envi(image_path)
            if self.rgb_only:
                if self.rgb_wl:
                    image, wl = mpu.rgb_subset_from_hsi(image, wl, rgb_target_wl=self.rgb_wl)
                else:
                    image, wl = mpu.rgb_subset_from_hsi(image, wl)

            # Insert nodata value in invalid pixels
            self._insert_image_nodata_value(image)

            # Read geotransform info and create GeoTIFF profile
            geotransform_data = mpu.read_json(geotransform_path)
            geotiff_profile = self.create_geotiff_profile(
                image,
                geotransform_parameters=geotransform_data["geotransform"],
                crs_epsg=geotransform_data["utm_epsg"],
            )

            # Write GeoTIFF file
            self.write_geotiff(
                geotiff_path,
                image,
                wl,
                geotiff_profile,
            )
        except Exception as e:
            logger.error(f"Error georeferencing hyperspectral image: {e}")
            raise

    def _insert_image_nodata_value(self, image: NDArray) -> None:
        """Insert nodata values in image (in-place)

        Parameters
        ----------
        image: NDArray
            3D image array ordered as (lines, samples, bands) Pixels where every band
            value is equal to zero are interpreted as invalid (no data).
        """
        nodata_mask = np.all(image == 0, axis=2)
        image[nodata_mask] = self.nodata_value

    def create_geotiff_profile(
        self,
        image: NDArray,
        geotransform_parameters: Union[List[float], Tuple[float, ...]],
        crs_epsg: int,
    ) -> dict:
        """Create profile for writing image as geotiff using rasterio

        Parameters
        ----------
        image: NDArray
            Path to image header (used to get image shape)
        geotransform_parameters: tuple
            6-element tuple describing affine transform from pixel coordinates to
            geographic coordinates. Ordered (A,B,C,D,E,F). See rasterio.transform.Affine
        crs_epsg: int
            EPSG code for CRS used.

        Returns
        -------
        profile: dict
            GeoTIFF profile to be used when saving GeoTIFF image.
        """

        transform = Affine(*geotransform_parameters)
        profile = DefaultGTiffProfile()
        profile.update(
            height=image.shape[0],
            width=image.shape[1],
            count=image.shape[2],
            dtype=str(image.dtype),
            crs=CRS.from_epsg(crs_epsg),
            transform=transform,
            nodata=self.nodata_value,
        )

        return profile  # type: ignore

    def calculate_non_rotated_geotiff_profile(
        self,
        src: rasterio.DatasetReader,
        resolution_decimals: int = 2,
    ) -> dict:
        """Create rasterio geotiff profile to reproject raster to non-rotated transform

        Parameters
        ----------
        src : rasterio.DatasetReader
            "Source" dataset opened in rasterio with rotated geotransform, i.e. "b" and
            "d" in geotransform are non-zero.
        resolution_decimals : int
            Number of decimals in calculated resolution for non-rotated geotiff Default
            is 2, corresponding to setting the resolution for UTM coordinates to an
            integer number of centimeters.

        Returns
        -------
        dst_profile: dict
            GeoTIFF profile for reprojection to non-rotated transform
        """
        # Calculate resolution
        if self.resolution is None:
            resolution = np.round(np.mean(src.res), decimals=resolution_decimals)
        else:
            resolution = self.resolution

        # Calculate transform and size of non-rotated raster
        non_rotated_transform, width, height = calculate_default_transform(
            src_crs=src.crs,
            dst_crs=src.crs,
            height=src.height,
            width=src.width,
            left=src.bounds.left,
            bottom=src.bounds.bottom,
            right=src.bounds.right,
            top=src.bounds.top,
            resolution=resolution,
        )
        dst_profile = src.meta.copy()
        dst_profile.update({"transform": non_rotated_transform, "width": width, "height": height})
        return dst_profile

    def write_geotiff(
        self,
        geotiff_path: Union[Path, str],
        image: NDArray,
        wavelengths: NDArray,
        geotiff_profile: dict,
    ) -> None:
        """Write image as GeoTIFF

        Parameters
        ----------
        geotiff_path : Union[Path, str]
            Path to (output) GeoTIFF file
        image : NDArray
            Image to write, shape (n_lines, n_samples, n_bands)
        wavelengths : NDArray
            Wavelengths (in nm) corresponding to each image band. The wavelengths are
            used to set the descption of each band in the GeoTIFF file.
        geotiff_profile : dict
            Dict with GeoTIFF parameters ("profile"), typically created using
            create_geotiff_profile()

        Notes
        -----
        Rasterio / GDAL requires the image to be ordered "bands first", e.g. shape
        (bands, lines, samples). However, the default used by e.g. the 'spectral'
        library is (lines, samples, bands), and this convention should be used
        consistenly to avoid bugs. This function moves the band axis directly before
        writing.
        """
        try:
            image = reshape_as_raster(image)  # Band ordering required by GeoTIFF
            band_names = [f"{wl:.3f}" for wl in wavelengths]

            if self.reproject_to_nonrotated_transform:
                # Use GDAL env. var. GDAL_PAM_ENABLED=False to hide false errors See
                # https://github.com/rasterio/rasterio/discussions/2825 for details
                with rasterio.Env(GDAL_PAM_ENABLED=False):
                    with MemoryFile() as memfile:
                        # Write rotated raster to in-memory file to open it as
                        # DatasetReader
                        with rasterio.open(memfile, "w", **geotiff_profile) as dataset:
                            for i in range(dataset.count):
                                dataset.set_band_description(i + 1, band_names[i])
                            dataset.write(image)

                        # Open in-memory rotated dataset as DatasetReader ("source")
                        with rasterio.open(memfile, "r") as src:
                            # Calculate transform and shape of non-rotated raster
                            dst_profile = self.calculate_non_rotated_geotiff_profile(src)

                            # Open output file as non-rotated destination raster dataset
                            with rasterio.open(geotiff_path, "w", **dst_profile) as dst:
                                # Loop over bands and reproject to non-rotated transform
                                for i in range(1, src.count + 1):
                                    dst.set_band_description(i, src.descriptions[i - 1])
                                    reproject(
                                        source=rasterio.band(src, i),
                                        destination=rasterio.band(dst, i),
                                        src_transform=src.transform,
                                        src_crs=src.crs,
                                        dst_transform=dst.transform,
                                        dst_crs=dst.crs,
                                        resampling=Resampling.nearest,
                                    )

            else:  # Use rotated geotransform (no reprojection needed)
                with rasterio.Env():
                    with rasterio.open(geotiff_path, "w", **geotiff_profile) as dataset:
                        if band_names is not None:
                            for i in range(dataset.count):
                                dataset.set_band_description(i + 1, band_names[i])
                        dataset.write(image)
        except Exception as e:
            logger.error(f"Error writing GeoTIFF: {e}")
            raise


def envi_map_info_to_geotransform(envi_map_info: str) -> Tuple[Affine, int]:
    """Parse ENVI map info to extract affine transform and EPSG code

    This function makes several limiting assumptions: - The image uses UTM CRS - The
    geotransform is not rotated (B and D in affine transform are zero)

    Example map info: map info = "{UTM, 1.000, 1.000, 497827.4184469187,
    7454593.548431687, 0.05, 0.05,
        33, North, WGS-84, units  meters, rotation  0.000}"
    """

    map_info = envi_map_info.lstrip("{").rstrip("}").replace(" ", "").split(",")
    C = float(map_info[3])  # x origin
    F = float(map_info[4])  # y origin
    A = float(map_info[5])  # x pixel size
    E = -float(map_info[6])  # y pixel size
    B, D = 0.0, 0.0
    transform = Affine(A, B, C, D, E, F)

    utm_zone = int(map_info[7])
    utm_south = str.lower(map_info[8]) == "south"
    crs = pyproj.CRS.from_dict({"proj": "utm", "zone": utm_zone, "south": utm_south})
    epsg = crs.to_epsg()
    if epsg is None:
        logger.error("EPSG code not found for UTM zone")
        raise ValueError("EPSG code not found for UTM zone")

    return transform, epsg


def georeferenced_hyspec_to_rgb_geotiff(
    hyspec_path: Union[Path, str],
    geotiff_path: Union[Path, str],
    rgb_wl: Optional[Tuple[float, float, float]] = None,
    nodata_value: float = 0.0,
) -> None:
    """Extract RGB bands from georeferenced hyperspectral image and save as GeoTIFF

    Parameters
    ----------
    hyspec_path : Union[Path, str]
        Path to hyperspectral image header. Assumes that path to binary image is the
        same, but without .hdr suffix
    geotiff_path : Union[Path, str]
        Path to (output) GeoTIFF
    rgb_wl : tuple[float, float, float]
        Target wavelengths for RGB bands (closest available bands will be used)

    Notes
    -----
    A nodata value of zero is assumed for the hyperspectral image.
    """

    rgb_wl = (460, 550, 640) if rgb_wl is None else rgb_wl  # Default wavelengths

    hyspec_path = Path(hyspec_path)

    _, wl = mpu.read_envi_header(hyspec_path)
    wl_ind = [mpu.closest_wl_index(wl, target_wl) for target_wl in rgb_wl]
    band_names = [f"{actual_wl:.3f}" for actual_wl in wl[wl_ind]]
    with rasterio.Env():
        with rasterio.open(hyspec_path.with_suffix("")) as src:  # path to binary file
            # Read the selected bands
            bands_data = [src.read(band) for band in wl_ind]

            # Modify profile for the output file
            profile = src.meta.copy()
            profile.update(
                {
                    "count": len(wl_ind),
                    "driver": "GTiff",
                    "dtype": bands_data[0].dtype,
                    "nodata": nodata_value,
                }
            )

            # Write the bands to a new GeoTIFF file
            with rasterio.open(geotiff_path, "w", **profile) as dst:
                for i, (band_data, band_name) in enumerate(zip(bands_data, band_names), start=1):
                    dst.write(band_data, i)
                    dst.set_band_description(i, band_name)
